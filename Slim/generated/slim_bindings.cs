// <auto-generated>
//     This file was generated by uniffi-bindgen-cs v0.9.0+v0.28.3
//     See https://github.com/NordSecurity/uniffi-bindgen-cs for more information.
// </auto-generated>

#nullable enable




using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
namespace uniffi.slim_bindings;



// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

[StructLayout(LayoutKind.Sequential)]
internal struct RustBuffer {
    public ulong capacity;
    public ulong len;
    public IntPtr data;

    public static RustBuffer Alloc(int size) {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            var buffer = _UniFFILib.ffi_slim_bindings_rustbuffer_alloc(Convert.ToUInt64(size), ref status);
            if (buffer.data == IntPtr.Zero) {
                throw new AllocationException($"RustBuffer.Alloc() returned null data pointer (size={size})");
            }
            return buffer;
        });
    }

    public static void Free(RustBuffer buffer) {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.ffi_slim_bindings_rustbuffer_free(buffer, ref status);
        });
    }

    public static BigEndianStream MemoryStream(IntPtr data, long length)
    {
        unsafe
        {
            return new BigEndianStream(new UnmanagedMemoryStream((byte*)data.ToPointer(), length));
        }
    }

    public BigEndianStream AsStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream((byte*)data.ToPointer(), Convert.ToInt64(len))
            );
        }
    }

    public BigEndianStream AsWriteableStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream(
                    (byte*)data.ToPointer(),
                    Convert.ToInt64(capacity),
                    Convert.ToInt64(capacity),
                    FileAccess.Write
                )
            );
        }
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to managed memory, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

[StructLayout(LayoutKind.Sequential)]
internal struct ForeignBytes {
    public int length;
    public IntPtr data;
}


// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
internal abstract class FfiConverter<CsType, FfiType> {
    // Convert an FFI type to a C# type
    public abstract CsType Lift(FfiType value);

    // Convert C# type to an FFI type
    public abstract FfiType Lower(CsType value);

    // Read a C# type from a `ByteBuffer`
    public abstract CsType Read(BigEndianStream stream);

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    public abstract int AllocationSize(CsType value);

    // Write a C# type to a `ByteBuffer`
    public abstract void Write(CsType value, BigEndianStream stream);

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    public RustBuffer LowerIntoRustBuffer(CsType value) {
        var rbuf = RustBuffer.Alloc(AllocationSize(value));
        try {
            var stream = rbuf.AsWriteableStream();
            Write(value, stream);
            rbuf.len = Convert.ToUInt64(stream.Position);
            return rbuf;
        } catch {
            RustBuffer.Free(rbuf);
            throw;
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    protected CsType LiftFromRustBuffer(RustBuffer rbuf) {
        var stream = rbuf.AsStream();
        try {
           var item = Read(stream);
           if (stream.HasRemaining()) {
               throw new InternalException("junk remaining in buffer after lifting, something is very wrong!!");
           }
           return item;
        } finally {
            RustBuffer.Free(rbuf);
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
internal abstract class FfiConverterRustBuffer<CsType>: FfiConverter<CsType, RustBuffer> {
    public override CsType Lift(RustBuffer value) {
        return LiftFromRustBuffer(value);
    }
    public override RustBuffer Lower(CsType value) {
        return LowerIntoRustBuffer(value);
    }
}


// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
[StructLayout(LayoutKind.Sequential)]
struct UniffiRustCallStatus {
    public sbyte code;
    public RustBuffer error_buf;

    public bool IsSuccess() {
        return code == 0;
    }

    public bool IsError() {
        return code == 1;
    }

    public bool IsPanic() {
        return code == 2;
    }
}

// Base class for all uniffi exceptions
internal class UniffiException: System.Exception {
    public UniffiException(): base() {}
    public UniffiException(string message): base(message) {}
}

internal class UndeclaredErrorException: UniffiException {
    public UndeclaredErrorException(string message): base(message) {}
}

internal class PanicException: UniffiException {
    public PanicException(string message): base(message) {}
}

internal class AllocationException: UniffiException {
    public AllocationException(string message): base(message) {}
}

internal class InternalException: UniffiException {
    public InternalException(string message): base(message) {}
}

internal class InvalidEnumException: InternalException {
    public InvalidEnumException(string message): base(message) {
    }
}

internal class UniffiContractVersionException: UniffiException {
    public UniffiContractVersionException(string message): base(message) {
    }
}

internal class UniffiContractChecksumException: UniffiException {
    public UniffiContractChecksumException(string message): base(message) {
    }
}

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E> where E: System.Exception {
    E Lift(RustBuffer error_buf);
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
class NullCallStatusErrorHandler: CallStatusErrorHandler<UniffiException> {
    public static NullCallStatusErrorHandler INSTANCE = new NullCallStatusErrorHandler();

    public UniffiException Lift(RustBuffer error_buf) {
        RustBuffer.Free(error_buf);
        return new UndeclaredErrorException("library has returned an error not declared in UNIFFI interface file");
    }
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself
class _UniffiHelpers {
    public delegate void RustCallAction(ref UniffiRustCallStatus status);
    public delegate U RustCallFunc<out U>(ref UniffiRustCallStatus status);

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static U RustCallWithError<U, E>(CallStatusErrorHandler<E> errorHandler, RustCallFunc<U> callback)
        where E: UniffiException
    {
        var status = new UniffiRustCallStatus();
        var return_value = callback(ref status);
        if (status.IsSuccess()) {
            return return_value;
        } else if (status.IsError()) {
            throw errorHandler.Lift(status.error_buf);
        } else if (status.IsPanic()) {
            // when the rust code sees a panic, it tries to construct a rustbuffer
            // with the message.  but if that code panics, then it just sends back
            // an empty buffer.
            if (status.error_buf.len > 0) {
                throw new PanicException(FfiConverterString.INSTANCE.Lift(status.error_buf));
            } else {
                throw new PanicException("Rust panic");
            }
        } else {
            throw new InternalException($"Unknown rust call status: {status.code}");
        }
    }

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static void RustCallWithError<E>(CallStatusErrorHandler<E> errorHandler, RustCallAction callback)
        where E: UniffiException
    {
        _UniffiHelpers.RustCallWithError(errorHandler, (ref UniffiRustCallStatus status) => {
            callback(ref status);
            return 0;
        });
    }

    // Call a rust function that returns a plain value
    public static U RustCall<U>(RustCallFunc<U> callback) {
        return _UniffiHelpers.RustCallWithError(NullCallStatusErrorHandler.INSTANCE, callback);
    }

    // Call a rust function that returns a plain value
    public static void RustCall(RustCallAction callback) {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            callback(ref status);
            return 0;
        });
    }
}

static class FFIObjectUtil {
    public static void DisposeAll(params Object?[] list) {
        foreach (var obj in list) {
            Dispose(obj);
        }
    }

    // Dispose is implemented by recursive type inspection at runtime. This is because
    // generating correct Dispose calls for recursive complex types, e.g. List<List<int>>
    // is quite cumbersome.
    private static void Dispose(dynamic? obj) {
        if (obj == null) {
            return;
        }

        if (obj is IDisposable disposable) {
            disposable.Dispose();
            return;
        }

        var type = obj.GetType();
        if (type != null) {
            if (type.IsGenericType) {
                if (type.GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))) {
                    foreach (var value in obj) {
                        Dispose(value);
                    }
                } else if (type.GetGenericTypeDefinition().IsAssignableFrom(typeof(Dictionary<,>))) {
                    foreach (var value in obj.Values) {
                        Dispose(value);
                    }
                }
            }
        }
    }
}


// Big endian streams are not yet available in dotnet :'(
// https://github.com/dotnet/runtime/issues/26904

class StreamUnderflowException: System.Exception {
    public StreamUnderflowException() {
    }
}

class BigEndianStream {
    Stream stream;
    public BigEndianStream(Stream stream) {
        this.stream = stream;
    }

    public bool HasRemaining() {
        return (stream.Length - stream.Position) > 0;
    }

    public long Position {
        get => stream.Position;
        set => stream.Position = value;
    }

    public void WriteBytes(byte[] value) {
        stream.Write(value, 0, value.Length);
    }

    public void WriteByte(byte value) {
        stream.WriteByte(value);
    }

    public void WriteUShort(ushort value) {
        stream.WriteByte((byte)(value >> 8));
        stream.WriteByte((byte)value);
    }

    public void WriteUInt(uint value) {
        stream.WriteByte((byte)(value >> 24));
        stream.WriteByte((byte)(value >> 16));
        stream.WriteByte((byte)(value >> 8));
        stream.WriteByte((byte)value);
    }

    public void WriteULong(ulong value) {
        WriteUInt((uint)(value >> 32));
        WriteUInt((uint)value);
    }

    public void WriteSByte(sbyte value) {
        stream.WriteByte((byte)value);
    }

    public void WriteShort(short value) {
        WriteUShort((ushort)value);
    }

    public void WriteInt(int value) {
        WriteUInt((uint)value);
    }

    public void WriteFloat(float value) {
        unsafe {
            WriteInt(*((int*)&value));
        }
    }

    public void WriteLong(long value) {
        WriteULong((ulong)value);
    }

    public void WriteDouble(double value) {
        WriteLong(BitConverter.DoubleToInt64Bits(value));
    }

    public byte[] ReadBytes(int length) {
        CheckRemaining(length);
        byte[] result = new byte[length];
        stream.Read(result, 0, length);
        return result;
    }

    public byte ReadByte() {
        CheckRemaining(1);
        return Convert.ToByte(stream.ReadByte());
    }

    public ushort ReadUShort() {
        CheckRemaining(2);
        return (ushort)(stream.ReadByte() << 8 | stream.ReadByte());
    }

    public uint ReadUInt() {
        CheckRemaining(4);
        return (uint)(stream.ReadByte() << 24
            | stream.ReadByte() << 16
            | stream.ReadByte() << 8
            | stream.ReadByte());
    }

    public ulong ReadULong() {
        return (ulong)ReadUInt() << 32 | (ulong)ReadUInt();
    }

    public sbyte ReadSByte() {
        return (sbyte)ReadByte();
    }

    public short ReadShort() {
        return (short)ReadUShort();
    }

    public int ReadInt() {
        return (int)ReadUInt();
    }

    public float ReadFloat() {
        unsafe {
            int value = ReadInt();
            return *((float*)&value);
        }
    }

    public long ReadLong() {
        return (long)ReadULong();
    }

    public double ReadDouble() {
        return BitConverter.Int64BitsToDouble(ReadLong());
    }

    private void CheckRemaining(int length) {
        if (stream.Length - stream.Position < length) {
            throw new StreamUnderflowException();
        }
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.


// This is an implementation detail that will be called internally by the public API.
static class _UniFFILib {
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiRustFutureContinuationCallback(
        ulong @data,sbyte @pollResult
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureFree(
        ulong @handle
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceFree(
        ulong @handle
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFuture
    {
        public ulong @handle;
        public IntPtr @free;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU8
    {
        public byte @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU8(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU8 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI8
    {
        public sbyte @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI8(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI8 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU16
    {
        public ushort @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU16(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU16 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI16
    {
        public short @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI16(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI16 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU32
    {
        public uint @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI32
    {
        public int @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU64
    {
        public ulong @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI64
    {
        public long @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructF32
    {
        public float @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteF32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructF32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructF64
    {
        public double @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteF64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructF64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructPointer
    {
        public IntPtr @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompletePointer(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructPointer @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructRustBuffer
    {
        public RustBuffer @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteRustBuffer(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructRustBuffer @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructVoid
    {
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteVoid(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructVoid @result
    );
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    static _UniFFILib() {
        _UniFFILib.uniffiCheckContractApiVersion();
        _UniFFILib.uniffiCheckApiChecksums();
        
        }

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_clone_app(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_free_app(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_constructor_app_new(IntPtr @baseName,RustBuffer @identityProviderConfig,RustBuffer @identityVerifierConfig,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_constructor_app_new_with_secret(IntPtr @name,RustBuffer @secret,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_method_app_create_session(IntPtr @ptr,RustBuffer @config,IntPtr @destination,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_app_create_session_and_wait(IntPtr @ptr,RustBuffer @config,IntPtr @destination,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_app_create_session_and_wait_async(IntPtr @ptr,RustBuffer @config,IntPtr @destination
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_app_create_session_async(IntPtr @ptr,RustBuffer @config,IntPtr @destination
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_app_delete_session(IntPtr @ptr,IntPtr @session,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_method_app_delete_session_and_wait(IntPtr @ptr,IntPtr @session,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_app_delete_session_and_wait_async(IntPtr @ptr,IntPtr @session
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_app_delete_session_async(IntPtr @ptr,IntPtr @session
    );

    [DllImport("slim_bindings")]
    public static extern ulong uniffi_slim_bindings_fn_method_app_id(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_app_listen_for_session(IntPtr @ptr,RustBuffer @timeout,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_app_listen_for_session_async(IntPtr @ptr,RustBuffer @timeout
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_app_name(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_method_app_remove_route(IntPtr @ptr,IntPtr @name,ulong @connectionId,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_app_remove_route_async(IntPtr @ptr,IntPtr @name,ulong @connectionId
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_method_app_set_route(IntPtr @ptr,IntPtr @name,ulong @connectionId,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_app_set_route_async(IntPtr @ptr,IntPtr @name,ulong @connectionId
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_method_app_subscribe(IntPtr @ptr,IntPtr @name,RustBuffer @connectionId,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_app_subscribe_async(IntPtr @ptr,IntPtr @name,RustBuffer @connectionId
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_method_app_unsubscribe(IntPtr @ptr,IntPtr @name,RustBuffer @connectionId,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_app_unsubscribe_async(IntPtr @ptr,IntPtr @name,RustBuffer @connectionId
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_clone_completionhandle(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_free_completionhandle(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_method_completionhandle_wait(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_completionhandle_wait_async(IntPtr @ptr
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_method_completionhandle_wait_for(IntPtr @ptr,RustBuffer @timeout,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_completionhandle_wait_for_async(IntPtr @ptr,RustBuffer @timeout
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_clone_name(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_free_name(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_constructor_name_new(RustBuffer @component0,RustBuffer @component1,RustBuffer @component2,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_constructor_name_new_with_id(RustBuffer @component0,RustBuffer @component1,RustBuffer @component2,ulong @id,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_method_name_as_string(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_method_name_components(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern ulong uniffi_slim_bindings_fn_method_name_id(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_clone_service(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_free_service(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_constructor_service_new(RustBuffer @name,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_constructor_service_new_with_config(RustBuffer @name,RustBuffer @config,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_method_service_config(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern ulong uniffi_slim_bindings_fn_method_service_connect(IntPtr @ptr,RustBuffer @config,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_service_connect_async(IntPtr @ptr,RustBuffer @config
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_service_create_app(IntPtr @ptr,IntPtr @baseName,RustBuffer @identityProviderConfig,RustBuffer @identityVerifierConfig,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_service_create_app_async(IntPtr @ptr,IntPtr @baseName,RustBuffer @identityProviderConfig,RustBuffer @identityVerifierConfig
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_service_create_app_with_secret(IntPtr @ptr,IntPtr @name,RustBuffer @secret,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_service_create_app_with_secret_async(IntPtr @ptr,IntPtr @name,RustBuffer @secret
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_method_service_disconnect(IntPtr @ptr,ulong @connId,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_method_service_get_connection_id(IntPtr @ptr,RustBuffer @endpoint,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_method_service_get_name(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_method_service_run(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_service_run_async(IntPtr @ptr
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_method_service_run_server(IntPtr @ptr,RustBuffer @config,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_service_run_server_async(IntPtr @ptr,RustBuffer @config
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_method_service_shutdown(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_service_shutdown_async(IntPtr @ptr
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_method_service_stop_server(IntPtr @ptr,RustBuffer @endpoint,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_clone_session(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_free_session(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_method_session_config(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_session_destination(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_method_session_get_message(IntPtr @ptr,RustBuffer @timeout,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_session_get_message_async(IntPtr @ptr,RustBuffer @timeout
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_session_invite(IntPtr @ptr,IntPtr @participant,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_method_session_invite_and_wait(IntPtr @ptr,IntPtr @participant,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_session_invite_and_wait_async(IntPtr @ptr,IntPtr @participant
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_session_invite_async(IntPtr @ptr,IntPtr @participant
    );

    [DllImport("slim_bindings")]
    public static extern sbyte uniffi_slim_bindings_fn_method_session_is_initiator(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_method_session_metadata(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_method_session_participants_list(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_session_participants_list_async(IntPtr @ptr
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_session_publish(IntPtr @ptr,RustBuffer @data,RustBuffer @payloadType,RustBuffer @metadata,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_method_session_publish_and_wait(IntPtr @ptr,RustBuffer @data,RustBuffer @payloadType,RustBuffer @metadata,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_session_publish_and_wait_async(IntPtr @ptr,RustBuffer @data,RustBuffer @payloadType,RustBuffer @metadata
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_session_publish_async(IntPtr @ptr,RustBuffer @data,RustBuffer @payloadType,RustBuffer @metadata
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_session_publish_to(IntPtr @ptr,RustBuffer @messageContext,RustBuffer @data,RustBuffer @payloadType,RustBuffer @metadata,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_method_session_publish_to_and_wait(IntPtr @ptr,RustBuffer @messageContext,RustBuffer @data,RustBuffer @payloadType,RustBuffer @metadata,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_session_publish_to_and_wait_async(IntPtr @ptr,RustBuffer @messageContext,RustBuffer @data,RustBuffer @payloadType,RustBuffer @metadata
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_session_publish_to_async(IntPtr @ptr,RustBuffer @messageContext,RustBuffer @data,RustBuffer @payloadType,RustBuffer @metadata
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_method_session_publish_with_params(IntPtr @ptr,IntPtr @destination,uint @fanout,RustBuffer @data,RustBuffer @connectionOut,RustBuffer @payloadType,RustBuffer @metadata,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_session_publish_with_params_async(IntPtr @ptr,IntPtr @destination,uint @fanout,RustBuffer @data,RustBuffer @connectionOut,RustBuffer @payloadType,RustBuffer @metadata
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_session_remove(IntPtr @ptr,IntPtr @participant,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_method_session_remove_and_wait(IntPtr @ptr,IntPtr @participant,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_session_remove_and_wait_async(IntPtr @ptr,IntPtr @participant
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_session_remove_async(IntPtr @ptr,IntPtr @participant
    );

    [DllImport("slim_bindings")]
    public static extern uint uniffi_slim_bindings_fn_method_session_session_id(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_method_session_session_type(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_method_session_source(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_func_create_service(RustBuffer @name,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_func_create_service_with_config(RustBuffer @name,RustBuffer @config,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_func_get_build_info(ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr uniffi_slim_bindings_fn_func_get_global_service(ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_func_get_services(ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_func_get_version(ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_func_initialize_from_config(RustBuffer @configPath,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_func_initialize_with_configs(RustBuffer @runtimeConfig,RustBuffer @tracingConfig,RustBuffer @serviceConfig,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_func_initialize_with_defaults(ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern sbyte uniffi_slim_bindings_fn_func_is_initialized(ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_func_new_dataplane_config(ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_func_new_insecure_client_config(RustBuffer @endpoint,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_func_new_insecure_server_config(RustBuffer @endpoint,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_func_new_runtime_config(ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_func_new_runtime_config_with(ulong @nCores,RustBuffer @threadName,RustBuffer @drainTimeout,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_func_new_server_config(RustBuffer @endpoint,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_func_new_service_config(ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_func_new_service_config_with(RustBuffer @nodeId,RustBuffer @groupName,RustBuffer @dataplane,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_func_new_service_configuration(ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_func_new_tracing_config(ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer uniffi_slim_bindings_fn_func_new_tracing_config_with(RustBuffer @logLevel,sbyte @displayThreadNames,sbyte @displayThreadIds,RustBuffer @filters,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void uniffi_slim_bindings_fn_func_shutdown_blocking(ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer ffi_slim_bindings_rustbuffer_alloc(ulong @size,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer ffi_slim_bindings_rustbuffer_from_bytes(ForeignBytes @bytes,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rustbuffer_free(RustBuffer @buf,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer ffi_slim_bindings_rustbuffer_reserve(RustBuffer @buf,ulong @additional,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_poll_u8(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_cancel_u8(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_free_u8(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern byte ffi_slim_bindings_rust_future_complete_u8(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_poll_i8(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_cancel_i8(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_free_i8(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern sbyte ffi_slim_bindings_rust_future_complete_i8(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_poll_u16(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_cancel_u16(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_free_u16(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern ushort ffi_slim_bindings_rust_future_complete_u16(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_poll_i16(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_cancel_i16(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_free_i16(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern short ffi_slim_bindings_rust_future_complete_i16(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_poll_u32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_cancel_u32(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_free_u32(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern uint ffi_slim_bindings_rust_future_complete_u32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_poll_i32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_cancel_i32(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_free_i32(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern int ffi_slim_bindings_rust_future_complete_i32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_poll_u64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_cancel_u64(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_free_u64(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern ulong ffi_slim_bindings_rust_future_complete_u64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_poll_i64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_cancel_i64(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_free_i64(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern long ffi_slim_bindings_rust_future_complete_i64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_poll_f32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_cancel_f32(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_free_f32(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern float ffi_slim_bindings_rust_future_complete_f32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_poll_f64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_cancel_f64(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_free_f64(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern double ffi_slim_bindings_rust_future_complete_f64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_poll_pointer(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_cancel_pointer(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_free_pointer(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern IntPtr ffi_slim_bindings_rust_future_complete_pointer(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_poll_rust_buffer(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_cancel_rust_buffer(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_free_rust_buffer(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern RustBuffer ffi_slim_bindings_rust_future_complete_rust_buffer(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_poll_void(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_cancel_void(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_free_void(IntPtr @handle
    );

    [DllImport("slim_bindings")]
    public static extern void ffi_slim_bindings_rust_future_complete_void(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_create_service(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_create_service_with_config(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_get_build_info(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_get_global_service(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_get_services(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_get_version(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_initialize_from_config(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_initialize_with_configs(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_initialize_with_defaults(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_is_initialized(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_new_dataplane_config(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_new_insecure_client_config(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_new_insecure_server_config(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_new_runtime_config(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_new_runtime_config_with(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_new_server_config(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_new_service_config(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_new_service_config_with(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_new_service_configuration(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_new_tracing_config(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_new_tracing_config_with(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_func_shutdown_blocking(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_app_create_session(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_app_create_session_and_wait(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_app_create_session_and_wait_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_app_create_session_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_app_delete_session(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_app_delete_session_and_wait(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_app_delete_session_and_wait_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_app_delete_session_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_app_id(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_app_listen_for_session(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_app_listen_for_session_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_app_name(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_app_remove_route(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_app_remove_route_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_app_set_route(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_app_set_route_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_app_subscribe(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_app_subscribe_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_app_unsubscribe(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_app_unsubscribe_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_completionhandle_wait(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_completionhandle_wait_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_completionhandle_wait_for(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_completionhandle_wait_for_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_name_as_string(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_name_components(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_name_id(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_service_config(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_service_connect(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_service_connect_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_service_create_app(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_service_create_app_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_service_create_app_with_secret(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_service_create_app_with_secret_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_service_disconnect(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_service_get_connection_id(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_service_get_name(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_service_run(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_service_run_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_service_run_server(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_service_run_server_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_service_shutdown(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_service_shutdown_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_service_stop_server(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_config(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_destination(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_get_message(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_get_message_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_invite(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_invite_and_wait(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_invite_and_wait_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_invite_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_is_initiator(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_metadata(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_participants_list(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_participants_list_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_publish(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_publish_and_wait(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_publish_and_wait_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_publish_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_publish_to(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_publish_to_and_wait(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_publish_to_and_wait_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_publish_to_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_publish_with_params(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_publish_with_params_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_remove(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_remove_and_wait(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_remove_and_wait_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_remove_async(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_session_id(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_session_type(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_method_session_source(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_constructor_app_new(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_constructor_app_new_with_secret(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_constructor_name_new(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_constructor_name_new_with_id(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_constructor_service_new(
    );

    [DllImport("slim_bindings")]
    public static extern ushort uniffi_slim_bindings_checksum_constructor_service_new_with_config(
    );

    [DllImport("slim_bindings")]
    public static extern uint ffi_slim_bindings_uniffi_contract_version(
    );

    

    static void uniffiCheckContractApiVersion() {
        var scaffolding_contract_version = _UniFFILib.ffi_slim_bindings_uniffi_contract_version();
        if (26 != scaffolding_contract_version) {
            throw new UniffiContractVersionException($"uniffi.slim_bindings: uniffi bindings expected version `26`, library returned `{scaffolding_contract_version}`");
        }
    }

    static void uniffiCheckApiChecksums() {
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_create_service();
            if (checksum != 50798) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_create_service` checksum `50798`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_create_service_with_config();
            if (checksum != 6614) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_create_service_with_config` checksum `6614`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_get_build_info();
            if (checksum != 20767) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_get_build_info` checksum `20767`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_get_global_service();
            if (checksum != 63486) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_get_global_service` checksum `63486`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_get_services();
            if (checksum != 58132) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_get_services` checksum `58132`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_get_version();
            if (checksum != 28442) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_get_version` checksum `28442`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_initialize_from_config();
            if (checksum != 7375) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_initialize_from_config` checksum `7375`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_initialize_with_configs();
            if (checksum != 4551) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_initialize_with_configs` checksum `4551`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_initialize_with_defaults();
            if (checksum != 58956) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_initialize_with_defaults` checksum `58956`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_is_initialized();
            if (checksum != 4144) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_is_initialized` checksum `4144`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_new_dataplane_config();
            if (checksum != 6114) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_new_dataplane_config` checksum `6114`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_new_insecure_client_config();
            if (checksum != 42525) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_new_insecure_client_config` checksum `42525`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_new_insecure_server_config();
            if (checksum != 40258) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_new_insecure_server_config` checksum `40258`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_new_runtime_config();
            if (checksum != 61090) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_new_runtime_config` checksum `61090`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_new_runtime_config_with();
            if (checksum != 39801) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_new_runtime_config_with` checksum `39801`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_new_server_config();
            if (checksum != 36482) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_new_server_config` checksum `36482`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_new_service_config();
            if (checksum != 58037) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_new_service_config` checksum `58037`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_new_service_config_with();
            if (checksum != 9565) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_new_service_config_with` checksum `9565`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_new_service_configuration();
            if (checksum != 51471) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_new_service_configuration` checksum `51471`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_new_tracing_config();
            if (checksum != 62274) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_new_tracing_config` checksum `62274`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_new_tracing_config_with();
            if (checksum != 52432) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_new_tracing_config_with` checksum `52432`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_func_shutdown_blocking();
            if (checksum != 6435) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_func_shutdown_blocking` checksum `6435`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_app_create_session();
            if (checksum != 43342) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_app_create_session` checksum `43342`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_app_create_session_and_wait();
            if (checksum != 26130) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_app_create_session_and_wait` checksum `26130`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_app_create_session_and_wait_async();
            if (checksum != 11981) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_app_create_session_and_wait_async` checksum `11981`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_app_create_session_async();
            if (checksum != 12561) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_app_create_session_async` checksum `12561`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_app_delete_session();
            if (checksum != 35432) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_app_delete_session` checksum `35432`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_app_delete_session_and_wait();
            if (checksum != 49247) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_app_delete_session_and_wait` checksum `49247`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_app_delete_session_and_wait_async();
            if (checksum != 21135) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_app_delete_session_and_wait_async` checksum `21135`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_app_delete_session_async();
            if (checksum != 57531) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_app_delete_session_async` checksum `57531`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_app_id();
            if (checksum != 25966) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_app_id` checksum `25966`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_app_listen_for_session();
            if (checksum != 8567) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_app_listen_for_session` checksum `8567`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_app_listen_for_session_async();
            if (checksum != 25092) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_app_listen_for_session_async` checksum `25092`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_app_name();
            if (checksum != 60302) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_app_name` checksum `60302`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_app_remove_route();
            if (checksum != 38502) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_app_remove_route` checksum `38502`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_app_remove_route_async();
            if (checksum != 6042) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_app_remove_route_async` checksum `6042`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_app_set_route();
            if (checksum != 60890) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_app_set_route` checksum `60890`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_app_set_route_async();
            if (checksum != 32403) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_app_set_route_async` checksum `32403`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_app_subscribe();
            if (checksum != 43519) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_app_subscribe` checksum `43519`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_app_subscribe_async();
            if (checksum != 53158) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_app_subscribe_async` checksum `53158`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_app_unsubscribe();
            if (checksum != 42801) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_app_unsubscribe` checksum `42801`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_app_unsubscribe_async();
            if (checksum != 44105) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_app_unsubscribe_async` checksum `44105`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_completionhandle_wait();
            if (checksum != 24983) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_completionhandle_wait` checksum `24983`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_completionhandle_wait_async();
            if (checksum != 35325) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_completionhandle_wait_async` checksum `35325`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_completionhandle_wait_for();
            if (checksum != 61981) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_completionhandle_wait_for` checksum `61981`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_completionhandle_wait_for_async();
            if (checksum != 7758) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_completionhandle_wait_for_async` checksum `7758`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_name_as_string();
            if (checksum != 25170) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_name_as_string` checksum `25170`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_name_components();
            if (checksum != 49977) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_name_components` checksum `49977`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_name_id();
            if (checksum != 28732) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_name_id` checksum `28732`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_service_config();
            if (checksum != 32098) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_service_config` checksum `32098`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_service_connect();
            if (checksum != 51734) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_service_connect` checksum `51734`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_service_connect_async();
            if (checksum != 25060) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_service_connect_async` checksum `25060`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_service_create_app();
            if (checksum != 6710) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_service_create_app` checksum `6710`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_service_create_app_async();
            if (checksum != 17578) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_service_create_app_async` checksum `17578`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_service_create_app_with_secret();
            if (checksum != 54746) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_service_create_app_with_secret` checksum `54746`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_service_create_app_with_secret_async();
            if (checksum != 43226) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_service_create_app_with_secret_async` checksum `43226`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_service_disconnect();
            if (checksum != 15579) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_service_disconnect` checksum `15579`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_service_get_connection_id();
            if (checksum != 21647) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_service_get_connection_id` checksum `21647`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_service_get_name();
            if (checksum != 14958) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_service_get_name` checksum `14958`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_service_run();
            if (checksum != 39615) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_service_run` checksum `39615`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_service_run_async();
            if (checksum != 12742) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_service_run_async` checksum `12742`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_service_run_server();
            if (checksum != 29360) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_service_run_server` checksum `29360`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_service_run_server_async();
            if (checksum != 24894) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_service_run_server_async` checksum `24894`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_service_shutdown();
            if (checksum != 9865) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_service_shutdown` checksum `9865`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_service_shutdown_async();
            if (checksum != 9544) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_service_shutdown_async` checksum `9544`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_service_stop_server();
            if (checksum != 52012) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_service_stop_server` checksum `52012`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_config();
            if (checksum != 40208) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_config` checksum `40208`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_destination();
            if (checksum != 42059) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_destination` checksum `42059`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_get_message();
            if (checksum != 53473) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_get_message` checksum `53473`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_get_message_async();
            if (checksum != 56667) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_get_message_async` checksum `56667`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_invite();
            if (checksum != 25093) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_invite` checksum `25093`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_invite_and_wait();
            if (checksum != 29134) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_invite_and_wait` checksum `29134`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_invite_and_wait_async();
            if (checksum != 27936) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_invite_and_wait_async` checksum `27936`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_invite_async();
            if (checksum != 3867) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_invite_async` checksum `3867`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_is_initiator();
            if (checksum != 55820) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_is_initiator` checksum `55820`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_metadata();
            if (checksum != 27503) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_metadata` checksum `27503`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_participants_list();
            if (checksum != 62568) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_participants_list` checksum `62568`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_participants_list_async();
            if (checksum != 13982) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_participants_list_async` checksum `13982`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_publish();
            if (checksum != 32701) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_publish` checksum `32701`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_publish_and_wait();
            if (checksum != 58778) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_publish_and_wait` checksum `58778`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_publish_and_wait_async();
            if (checksum != 4151) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_publish_and_wait_async` checksum `4151`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_publish_async();
            if (checksum != 8206) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_publish_async` checksum `8206`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_publish_to();
            if (checksum != 18923) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_publish_to` checksum `18923`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_publish_to_and_wait();
            if (checksum != 53774) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_publish_to_and_wait` checksum `53774`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_publish_to_and_wait_async();
            if (checksum != 62190) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_publish_to_and_wait_async` checksum `62190`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_publish_to_async();
            if (checksum != 48126) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_publish_to_async` checksum `48126`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_publish_with_params();
            if (checksum != 40703) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_publish_with_params` checksum `40703`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_publish_with_params_async();
            if (checksum != 16343) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_publish_with_params_async` checksum `16343`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_remove();
            if (checksum != 19253) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_remove` checksum `19253`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_remove_and_wait();
            if (checksum != 46797) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_remove_and_wait` checksum `46797`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_remove_and_wait_async();
            if (checksum != 23062) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_remove_and_wait_async` checksum `23062`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_remove_async();
            if (checksum != 702) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_remove_async` checksum `702`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_session_id();
            if (checksum != 54096) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_session_id` checksum `54096`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_session_type();
            if (checksum != 62208) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_session_type` checksum `62208`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_method_session_source();
            if (checksum != 18512) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_method_session_source` checksum `18512`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_constructor_app_new();
            if (checksum != 29282) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_constructor_app_new` checksum `29282`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_constructor_app_new_with_secret();
            if (checksum != 34848) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_constructor_app_new_with_secret` checksum `34848`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_constructor_name_new();
            if (checksum != 17614) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_constructor_name_new` checksum `17614`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_constructor_name_new_with_id();
            if (checksum != 54828) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_constructor_name_new_with_id` checksum `54828`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_constructor_service_new();
            if (checksum != 45367) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_constructor_service_new` checksum `45367`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_slim_bindings_checksum_constructor_service_new_with_config();
            if (checksum != 16863) {
                throw new UniffiContractChecksumException($"uniffi.slim_bindings: uniffi bindings expected function `uniffi_slim_bindings_checksum_constructor_service_new_with_config` checksum `16863`, library returned `{checksum}`");
            }
        }
    }
}

// Public interface members begin here.

#pragma warning disable 8625




class FfiConverterUInt32: FfiConverter<uint, uint> {
    public static FfiConverterUInt32 INSTANCE = new FfiConverterUInt32();

    public override uint Lift(uint value) {
        return value;
    }

    public override uint Read(BigEndianStream stream) {
        return stream.ReadUInt();
    }

    public override uint Lower(uint value) {
        return value;
    }

    public override int AllocationSize(uint value) {
        return 4;
    }

    public override void Write(uint value, BigEndianStream stream) {
        stream.WriteUInt(value);
    }
}



class FfiConverterUInt64: FfiConverter<ulong, ulong> {
    public static FfiConverterUInt64 INSTANCE = new FfiConverterUInt64();

    public override ulong Lift(ulong value) {
        return value;
    }

    public override ulong Read(BigEndianStream stream) {
        return stream.ReadULong();
    }

    public override ulong Lower(ulong value) {
        return value;
    }

    public override int AllocationSize(ulong value) {
        return 8;
    }

    public override void Write(ulong value, BigEndianStream stream) {
        stream.WriteULong(value);
    }
}



class FfiConverterBoolean: FfiConverter<bool, sbyte> {
    public static FfiConverterBoolean INSTANCE = new FfiConverterBoolean();

    public override bool Lift(sbyte value) {
        return value != 0;
    }

    public override bool Read(BigEndianStream stream) {
        return Lift(stream.ReadSByte());
    }

    public override sbyte Lower(bool value) {
        return value ? (sbyte)1 : (sbyte)0;
    }

    public override int AllocationSize(bool value) {
        return (sbyte)1;
    }

    public override void Write(bool value, BigEndianStream stream) {
        stream.WriteSByte(Lower(value));
    }
}



class FfiConverterString: FfiConverter<string, RustBuffer> {
    public static FfiConverterString INSTANCE = new FfiConverterString();

    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    public override string Lift(RustBuffer value) {
        try {
            var bytes = value.AsStream().ReadBytes(Convert.ToInt32(value.len));
            return System.Text.Encoding.UTF8.GetString(bytes);
        } finally {
            RustBuffer.Free(value);
        }
    }

    public override string Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var bytes = stream.ReadBytes(length);
        return System.Text.Encoding.UTF8.GetString(bytes);
    }

    public override RustBuffer Lower(string value) {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        var rbuf = RustBuffer.Alloc(bytes.Length);
        rbuf.AsWriteableStream().WriteBytes(bytes);
        return rbuf;
    }

    // TODO(CS)
    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per unicode codepoint which will always be
    // enough.
    public override int AllocationSize(string value) {
        const int sizeForLength = 4;
        var sizeForString = System.Text.Encoding.UTF8.GetByteCount(value);
        return sizeForLength + sizeForString;
    }

    public override void Write(string value, BigEndianStream stream) {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        stream.WriteInt(bytes.Length);
        stream.WriteBytes(bytes);
    }
}




class FfiConverterByteArray: FfiConverterRustBuffer<byte[]> {
    public static FfiConverterByteArray INSTANCE = new FfiConverterByteArray();

    public override byte[] Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        return stream.ReadBytes(length);
    }

    public override int AllocationSize(byte[] value) {
        return 4 + value.Length;
    }

    public override void Write(byte[] value, BigEndianStream stream) {
        stream.WriteInt(value.Length);
        stream.WriteBytes(value);
    }
}




class FfiConverterDuration: FfiConverterRustBuffer<TimeSpan> {
    public static FfiConverterDuration INSTANCE = new FfiConverterDuration();

    // https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/TimeSpan.cs
    private const uint NanosecondsPerTick = 100;

    public override TimeSpan Read(BigEndianStream stream) {
        var seconds = stream.ReadULong();
        var nanoseconds = stream.ReadUInt();
        var ticks = seconds * TimeSpan.TicksPerSecond;
        ticks += nanoseconds / NanosecondsPerTick;
        return new TimeSpan(Convert.ToInt64(ticks));
    }

    public override int AllocationSize(TimeSpan value) {
        // 8 bytes for seconds, 4 bytes for nanoseconds
        return 12;
    }

    public override void Write(TimeSpan value, BigEndianStream stream) {
        stream.WriteULong(Convert.ToUInt64(value.Ticks / TimeSpan.TicksPerSecond));
        stream.WriteUInt(Convert.ToUInt32(value.Ticks % TimeSpan.TicksPerSecond * NanosecondsPerTick));
    }
}



/// <summary>
/// Adapter that bridges the App API with language-bindings interface
///
/// This adapter uses enum-based auth types (`AuthProvider`/`AuthVerifier`) instead of generics
/// to be compatible with UniFFI, supporting multiple authentication mechanisms (SharedSecret,
/// JWT, SPIRE, StaticToken). It provides both synchronous (blocking) and asynchronous methods
/// for flexibility.
/// </summary>
internal interface IApp {
    /// <summary>
    /// Create a new session (blocking version for FFI)
    ///
    /// Returns a SessionWithCompletion containing the session context and a completion handle.
    /// Call `.wait()` on the completion handle to wait for session establishment.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    SessionWithCompletion CreateSession(SessionConfig @config, Name @destination);
    /// <summary>
    /// Create a new session and wait for completion (blocking version)
    ///
    /// This method creates a session and blocks until the session establishment completes.
    /// Returns only the session context, as the completion has already been awaited.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Session CreateSessionAndWait(SessionConfig @config, Name @destination);
    /// <summary>
    /// Create a new session and wait for completion (async version)
    ///
    /// This method creates a session and waits until the session establishment completes.
    /// Returns only the session context, as the completion has already been awaited.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task<Session> CreateSessionAndWaitAsync(SessionConfig @config, Name @destination);
    /// <summary>
    /// Create a new session (async version)
    ///
    /// Returns a SessionWithCompletion containing the session context and a completion handle.
    /// Await the completion handle to wait for session establishment.
    /// For point-to-point sessions, this ensures the remote peer has acknowledged the session.
    /// For multicast sessions, this ensures the initial setup is complete.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task<SessionWithCompletion> CreateSessionAsync(SessionConfig @config, Name @destination);
    /// <summary>
    /// Delete a session (blocking version for FFI)
    ///
    /// Returns a completion handle that can be awaited to ensure the deletion completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    CompletionHandle DeleteSession(Session @session);
    /// <summary>
    /// Delete a session and wait for completion (blocking version)
    ///
    /// This method deletes a session and blocks until the deletion completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    void DeleteSessionAndWait(Session @session);
    /// <summary>
    /// Delete a session and wait for completion (async version)
    ///
    /// This method deletes a session and waits until the deletion completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task DeleteSessionAndWaitAsync(Session @session);
    /// <summary>
    /// Delete a session (async version)
    ///
    /// Returns a completion handle that can be awaited to ensure the deletion completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task<CompletionHandle> DeleteSessionAsync(Session @session);
    /// <summary>
    /// Get the app ID (derived from name)
    /// </summary>
    ulong Id();
    /// <summary>
    /// Listen for incoming sessions (blocking version for FFI)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Session ListenForSession(TimeSpan? @timeout);
    /// <summary>
    /// Listen for incoming sessions (async version)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task<Session> ListenForSessionAsync(TimeSpan? @timeout);
    /// <summary>
    /// Get the app name
    /// </summary>
    Name Name();
    /// <summary>
    /// Remove a route (blocking version for FFI)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    void RemoveRoute(Name @name, ulong @connectionId);
    /// <summary>
    /// Remove a route (async version)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task RemoveRouteAsync(Name @name, ulong @connectionId);
    /// <summary>
    /// Set a route to a name for a specific connection (blocking version for FFI)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    void SetRoute(Name @name, ulong @connectionId);
    /// <summary>
    /// Set a route to a name for a specific connection (async version)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task SetRouteAsync(Name @name, ulong @connectionId);
    /// <summary>
    /// Subscribe to a session name (blocking version for FFI)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    void Subscribe(Name @name, ulong? @connectionId);
    /// <summary>
    /// Subscribe to a name (async version)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task SubscribeAsync(Name @name, ulong? @connectionId);
    /// <summary>
    /// Unsubscribe from a name (blocking version for FFI)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    void Unsubscribe(Name @name, ulong? @connectionId);
    /// <summary>
    /// Unsubscribe from a name (async version)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task UnsubscribeAsync(Name @name, ulong? @connectionId);
}
/// <summary>
/// Adapter that bridges the App API with language-bindings interface
///
/// This adapter uses enum-based auth types (`AuthProvider`/`AuthVerifier`) instead of generics
/// to be compatible with UniFFI, supporting multiple authentication mechanisms (SharedSecret,
/// JWT, SPIRE, StaticToken). It provides both synchronous (blocking) and asynchronous methods
/// for flexibility.
/// </summary>
internal class App : IApp, IDisposable {
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public App(IntPtr pointer) {
        this.pointer = pointer;
    }

    ~App() {
        Destroy();
    }
    /// <summary>
    /// Create a new App with identity provider and verifier configurations
    ///
    /// This is the main entry point for creating a SLIM application from language bindings.
    ///
    /// # Arguments
    /// * `base_name` - The base name for the app (without ID)
    /// * `identity_provider_config` - Configuration for proving identity to others
    /// * `identity_verifier_config` - Configuration for verifying identity of others
    ///
    /// # Returns
    /// * `Ok(Arc<App>)` - Successfully created adapter
    /// * `Err(SlimError)` - If adapter creation fails
    ///
    /// # Supported Identity Types
    /// - SharedSecret: Symmetric key authentication
    /// - JWT: Dynamic JWT generation/verification with signing/decoding keys
    /// - StaticJWT: Static JWT loaded from file with auto-reload
    /// </summary>
    public App(Name @baseName, IdentityProviderConfig @identityProviderConfig, IdentityVerifierConfig @identityVerifierConfig) :
        this(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_constructor_app_new(FfiConverterTypeName.INSTANCE.Lower(@baseName), FfiConverterTypeIdentityProviderConfig.INSTANCE.Lower(@identityProviderConfig), FfiConverterTypeIdentityVerifierConfig.INSTANCE.Lower(@identityVerifierConfig), ref _status)
)) {}

    protected void FreeRustArcPtr() {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.uniffi_slim_bindings_fn_free_app(this.pointer, ref status);
        });
    }

    protected IntPtr CloneRustArcPtr() {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            return _UniFFILib.uniffi_slim_bindings_fn_clone_app(this.pointer, ref status);
        });
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter() 
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
            if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter() 
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0) {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try {
            action(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {   
        IncrementCallCounter();
        try {
            return func(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    
    /// <summary>
    /// Create a new session (blocking version for FFI)
    ///
    /// Returns a SessionWithCompletion containing the session context and a completion handle.
    /// Call `.wait()` on the completion handle to wait for session establishment.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public SessionWithCompletion CreateSession(SessionConfig @config, Name @destination) {
        return CallWithPointer(thisPtr => FfiConverterTypeSessionWithCompletion.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_app_create_session(thisPtr, FfiConverterTypeSessionConfig.INSTANCE.Lower(@config), FfiConverterTypeName.INSTANCE.Lower(@destination), ref _status)
)));
    }
    
    
    /// <summary>
    /// Create a new session and wait for completion (blocking version)
    ///
    /// This method creates a session and blocks until the session establishment completes.
    /// Returns only the session context, as the completion has already been awaited.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public Session CreateSessionAndWait(SessionConfig @config, Name @destination) {
        return CallWithPointer(thisPtr => FfiConverterTypeSession.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_app_create_session_and_wait(thisPtr, FfiConverterTypeSessionConfig.INSTANCE.Lower(@config), FfiConverterTypeName.INSTANCE.Lower(@destination), ref _status)
)));
    }
    
    
    /// <summary>
    /// Create a new session and wait for completion (async version)
    ///
    /// This method creates a session and waits until the session establishment completes.
    /// Returns only the session context, as the completion has already been awaited.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task<Session> CreateSessionAndWaitAsync(SessionConfig @config, Name @destination) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_app_create_session_and_wait_async(thisPtr, FfiConverterTypeSessionConfig.INSTANCE.Lower(@config), FfiConverterTypeName.INSTANCE.Lower(@destination));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_pointer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_slim_bindings_rust_future_complete_pointer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_pointer(future),
        // Lift
        (result) => FfiConverterTypeSession.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Create a new session (async version)
    ///
    /// Returns a SessionWithCompletion containing the session context and a completion handle.
    /// Await the completion handle to wait for session establishment.
    /// For point-to-point sessions, this ensures the remote peer has acknowledged the session.
    /// For multicast sessions, this ensures the initial setup is complete.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task<SessionWithCompletion> CreateSessionAsync(SessionConfig @config, Name @destination) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_app_create_session_async(thisPtr, FfiConverterTypeSessionConfig.INSTANCE.Lower(@config), FfiConverterTypeName.INSTANCE.Lower(@destination));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_slim_bindings_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeSessionWithCompletion.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Delete a session (blocking version for FFI)
    ///
    /// Returns a completion handle that can be awaited to ensure the deletion completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public CompletionHandle DeleteSession(Session @session) {
        return CallWithPointer(thisPtr => FfiConverterTypeCompletionHandle.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_app_delete_session(thisPtr, FfiConverterTypeSession.INSTANCE.Lower(@session), ref _status)
)));
    }
    
    
    /// <summary>
    /// Delete a session and wait for completion (blocking version)
    ///
    /// This method deletes a session and blocks until the deletion completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public void DeleteSessionAndWait(Session @session) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_app_delete_session_and_wait(thisPtr, FfiConverterTypeSession.INSTANCE.Lower(@session), ref _status)
));
    }
    
    
    
    /// <summary>
    /// Delete a session and wait for completion (async version)
    ///
    /// This method deletes a session and waits until the deletion completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task DeleteSessionAndWaitAsync(Session @session) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_app_delete_session_and_wait_async(thisPtr, FfiConverterTypeSession.INSTANCE.Lower(@session));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_slim_bindings_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_void(future),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Delete a session (async version)
    ///
    /// Returns a completion handle that can be awaited to ensure the deletion completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task<CompletionHandle> DeleteSessionAsync(Session @session) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_app_delete_session_async(thisPtr, FfiConverterTypeSession.INSTANCE.Lower(@session));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_pointer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_slim_bindings_rust_future_complete_pointer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_pointer(future),
        // Lift
        (result) => FfiConverterTypeCompletionHandle.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Get the app ID (derived from name)
    /// </summary>
    public ulong Id() {
        return CallWithPointer(thisPtr => FfiConverterUInt64.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_app_id(thisPtr,  ref _status)
)));
    }
    
    
    /// <summary>
    /// Listen for incoming sessions (blocking version for FFI)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public Session ListenForSession(TimeSpan? @timeout) {
        return CallWithPointer(thisPtr => FfiConverterTypeSession.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_app_listen_for_session(thisPtr, FfiConverterOptionalDuration.INSTANCE.Lower(@timeout), ref _status)
)));
    }
    
    
    /// <summary>
    /// Listen for incoming sessions (async version)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task<Session> ListenForSessionAsync(TimeSpan? @timeout) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_app_listen_for_session_async(thisPtr, FfiConverterOptionalDuration.INSTANCE.Lower(@timeout));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_pointer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_slim_bindings_rust_future_complete_pointer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_pointer(future),
        // Lift
        (result) => FfiConverterTypeSession.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Get the app name
    /// </summary>
    public Name Name() {
        return CallWithPointer(thisPtr => FfiConverterTypeName.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_app_name(thisPtr,  ref _status)
)));
    }
    
    
    /// <summary>
    /// Remove a route (blocking version for FFI)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public void RemoveRoute(Name @name, ulong @connectionId) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_app_remove_route(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@name), FfiConverterUInt64.INSTANCE.Lower(@connectionId), ref _status)
));
    }
    
    
    
    /// <summary>
    /// Remove a route (async version)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task RemoveRouteAsync(Name @name, ulong @connectionId) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_app_remove_route_async(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@name), FfiConverterUInt64.INSTANCE.Lower(@connectionId));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_slim_bindings_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_void(future),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Set a route to a name for a specific connection (blocking version for FFI)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public void SetRoute(Name @name, ulong @connectionId) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_app_set_route(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@name), FfiConverterUInt64.INSTANCE.Lower(@connectionId), ref _status)
));
    }
    
    
    
    /// <summary>
    /// Set a route to a name for a specific connection (async version)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task SetRouteAsync(Name @name, ulong @connectionId) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_app_set_route_async(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@name), FfiConverterUInt64.INSTANCE.Lower(@connectionId));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_slim_bindings_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_void(future),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Subscribe to a session name (blocking version for FFI)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public void Subscribe(Name @name, ulong? @connectionId) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_app_subscribe(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@name), FfiConverterOptionalUInt64.INSTANCE.Lower(@connectionId), ref _status)
));
    }
    
    
    
    /// <summary>
    /// Subscribe to a name (async version)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task SubscribeAsync(Name @name, ulong? @connectionId) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_app_subscribe_async(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@name), FfiConverterOptionalUInt64.INSTANCE.Lower(@connectionId));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_slim_bindings_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_void(future),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Unsubscribe from a name (blocking version for FFI)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public void Unsubscribe(Name @name, ulong? @connectionId) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_app_unsubscribe(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@name), FfiConverterOptionalUInt64.INSTANCE.Lower(@connectionId), ref _status)
));
    }
    
    
    
    /// <summary>
    /// Unsubscribe from a name (async version)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task UnsubscribeAsync(Name @name, ulong? @connectionId) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_app_unsubscribe_async(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@name), FfiConverterOptionalUInt64.INSTANCE.Lower(@connectionId));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_slim_bindings_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_void(future),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    

    
    /// <summary>
    /// Create a new App with SharedSecret authentication (blocking version)
    ///
    /// This is a convenience function for creating a SLIM application using SharedSecret authentication.
    ///
    /// # Arguments
    /// * `name` - The base name for the app (without ID)
    /// * `secret` - The shared secret string for authentication
    ///
    /// # Returns
    /// * `Ok(Arc<App>)` - Successfully created adapter
    /// * `Err(SlimError)` - If adapter creation fails
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public static App NewWithSecret(Name @name, String @secret) {
        return new App(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_constructor_app_new_with_secret(FfiConverterTypeName.INSTANCE.Lower(@name), FfiConverterString.INSTANCE.Lower(@secret), ref _status)
));
    }
    
    
}
class FfiConverterTypeApp: FfiConverter<App, IntPtr> {
    public static FfiConverterTypeApp INSTANCE = new FfiConverterTypeApp();


    public override IntPtr Lower(App value) {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override App Lift(IntPtr value) {
        return new App(value);
    }

    public override App Read(BigEndianStream stream) {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(App value) {
        return 8;
    }

    public override void Write(App value, BigEndianStream stream) {
        stream.WriteLong(Lower(value).ToInt64());
    }
}



/// <summary>
/// FFI-compatible completion handle for async operations
///
/// Represents a pending operation that can be awaited to ensure completion.
/// Used for operations that need delivery confirmation or handshake acknowledgment.
///
/// # Examples
///
/// Basic usage:
/// ```ignore
/// let completion = session.publish(data, None, None)?;
/// completion.wait()?; // Wait for delivery confirmation
/// ```
/// </summary>
internal interface ICompletionHandle {
    /// <summary>
    /// Wait for the operation to complete indefinitely (blocking version)
    ///
    /// This blocks the calling thread until the operation completes.
    /// Use this from Go or other languages when you need to ensure
    /// an operation has finished before proceeding.
    ///
    /// **Note:** This can only be called once per handle. Subsequent calls
    /// will return an error.
    ///
    /// # Returns
    /// * `Ok(())` - Operation completed successfully
    /// * `Err(SlimError)` - Operation failed or handle already consumed
    /// </summary>
    /// <exception cref="SlimException"></exception>
    void Wait();
    /// <summary>
    /// Wait for the operation to complete indefinitely (async version)
    ///
    /// This is the async version that integrates with UniFFI's polling mechanism.
    /// The operation will yield control while waiting.
    ///
    /// **Note:** This can only be called once per handle. Subsequent calls
    /// will return an error.
    ///
    /// # Returns
    /// * `Ok(())` - Operation completed successfully
    /// * `Err(SlimError)` - Operation failed or handle already consumed
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task WaitAsync();
    /// <summary>
    /// Wait for the operation to complete with a timeout (blocking version)
    ///
    /// This blocks the calling thread until the operation completes or the timeout expires.
    /// Use this from Go or other languages when you need to ensure
    /// an operation has finished before proceeding with a time limit.
    ///
    /// **Note:** This can only be called once per handle. Subsequent calls
    /// will return an error.
    ///
    /// # Arguments
    /// * `timeout` - Maximum time to wait for completion
    ///
    /// # Returns
    /// * `Ok(())` - Operation completed successfully
    /// * `Err(SlimError::Timeout)` - If the operation timed out
    /// * `Err(SlimError)` - Operation failed or handle already consumed
    /// </summary>
    /// <exception cref="SlimException"></exception>
    void WaitFor(TimeSpan @timeout);
    /// <summary>
    /// Wait for the operation to complete with a timeout (async version)
    ///
    /// This is the async version that integrates with UniFFI's polling mechanism.
    /// The operation will yield control while waiting until completion or timeout.
    ///
    /// **Note:** This can only be called once per handle. Subsequent calls
    /// will return an error.
    ///
    /// # Arguments
    /// * `timeout` - Maximum time to wait for completion
    ///
    /// # Returns
    /// * `Ok(())` - Operation completed successfully
    /// * `Err(SlimError::Timeout)` - If the operation timed out
    /// * `Err(SlimError)` - Operation failed or handle already consumed
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task WaitForAsync(TimeSpan @timeout);
}
/// <summary>
/// FFI-compatible completion handle for async operations
///
/// Represents a pending operation that can be awaited to ensure completion.
/// Used for operations that need delivery confirmation or handshake acknowledgment.
///
/// # Examples
///
/// Basic usage:
/// ```ignore
/// let completion = session.publish(data, None, None)?;
/// completion.wait()?; // Wait for delivery confirmation
/// ```
/// </summary>
internal class CompletionHandle : ICompletionHandle, IDisposable {
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public CompletionHandle(IntPtr pointer) {
        this.pointer = pointer;
    }

    ~CompletionHandle() {
        Destroy();
    }

    protected void FreeRustArcPtr() {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.uniffi_slim_bindings_fn_free_completionhandle(this.pointer, ref status);
        });
    }

    protected IntPtr CloneRustArcPtr() {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            return _UniFFILib.uniffi_slim_bindings_fn_clone_completionhandle(this.pointer, ref status);
        });
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter() 
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
            if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter() 
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0) {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try {
            action(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {   
        IncrementCallCounter();
        try {
            return func(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    
    /// <summary>
    /// Wait for the operation to complete indefinitely (blocking version)
    ///
    /// This blocks the calling thread until the operation completes.
    /// Use this from Go or other languages when you need to ensure
    /// an operation has finished before proceeding.
    ///
    /// **Note:** This can only be called once per handle. Subsequent calls
    /// will return an error.
    ///
    /// # Returns
    /// * `Ok(())` - Operation completed successfully
    /// * `Err(SlimError)` - Operation failed or handle already consumed
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public void Wait() {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_completionhandle_wait(thisPtr,  ref _status)
));
    }
    
    
    
    /// <summary>
    /// Wait for the operation to complete indefinitely (async version)
    ///
    /// This is the async version that integrates with UniFFI's polling mechanism.
    /// The operation will yield control while waiting.
    ///
    /// **Note:** This can only be called once per handle. Subsequent calls
    /// will return an error.
    ///
    /// # Returns
    /// * `Ok(())` - Operation completed successfully
    /// * `Err(SlimError)` - Operation failed or handle already consumed
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task WaitAsync() {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_completionhandle_wait_async(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_slim_bindings_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_void(future),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Wait for the operation to complete with a timeout (blocking version)
    ///
    /// This blocks the calling thread until the operation completes or the timeout expires.
    /// Use this from Go or other languages when you need to ensure
    /// an operation has finished before proceeding with a time limit.
    ///
    /// **Note:** This can only be called once per handle. Subsequent calls
    /// will return an error.
    ///
    /// # Arguments
    /// * `timeout` - Maximum time to wait for completion
    ///
    /// # Returns
    /// * `Ok(())` - Operation completed successfully
    /// * `Err(SlimError::Timeout)` - If the operation timed out
    /// * `Err(SlimError)` - Operation failed or handle already consumed
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public void WaitFor(TimeSpan @timeout) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_completionhandle_wait_for(thisPtr, FfiConverterDuration.INSTANCE.Lower(@timeout), ref _status)
));
    }
    
    
    
    /// <summary>
    /// Wait for the operation to complete with a timeout (async version)
    ///
    /// This is the async version that integrates with UniFFI's polling mechanism.
    /// The operation will yield control while waiting until completion or timeout.
    ///
    /// **Note:** This can only be called once per handle. Subsequent calls
    /// will return an error.
    ///
    /// # Arguments
    /// * `timeout` - Maximum time to wait for completion
    ///
    /// # Returns
    /// * `Ok(())` - Operation completed successfully
    /// * `Err(SlimError::Timeout)` - If the operation timed out
    /// * `Err(SlimError)` - Operation failed or handle already consumed
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task WaitForAsync(TimeSpan @timeout) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_completionhandle_wait_for_async(thisPtr, FfiConverterDuration.INSTANCE.Lower(@timeout));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_slim_bindings_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_void(future),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    

    
}
class FfiConverterTypeCompletionHandle: FfiConverter<CompletionHandle, IntPtr> {
    public static FfiConverterTypeCompletionHandle INSTANCE = new FfiConverterTypeCompletionHandle();


    public override IntPtr Lower(CompletionHandle value) {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override CompletionHandle Lift(IntPtr value) {
        return new CompletionHandle(value);
    }

    public override CompletionHandle Read(BigEndianStream stream) {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(CompletionHandle value) {
        return 8;
    }

    public override void Write(CompletionHandle value, BigEndianStream stream) {
        stream.WriteLong(Lower(value).ToInt64());
    }
}



/// <summary>
/// Name type for SLIM (Secure Low-Latency Interactive Messaging)
/// </summary>
internal interface IName {
    String AsString();
    /// <summary>
    /// Get the name components as a vector of strings
    /// </summary>
    List<String> Components();
    /// <summary>
    /// Get the name ID
    /// </summary>
    ulong Id();
}
/// <summary>
/// Name type for SLIM (Secure Low-Latency Interactive Messaging)
/// </summary>
internal class Name : IName, IDisposable {
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public Name(IntPtr pointer) {
        this.pointer = pointer;
    }

    ~Name() {
        Destroy();
    }
    /// <summary>
    /// Create a new Name from components without an ID
    /// </summary>
    public Name(String @component0, String @component1, String @component2) :
        this(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_constructor_name_new(FfiConverterString.INSTANCE.Lower(@component0), FfiConverterString.INSTANCE.Lower(@component1), FfiConverterString.INSTANCE.Lower(@component2), ref _status)
)) {}

    protected void FreeRustArcPtr() {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.uniffi_slim_bindings_fn_free_name(this.pointer, ref status);
        });
    }

    protected IntPtr CloneRustArcPtr() {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            return _UniFFILib.uniffi_slim_bindings_fn_clone_name(this.pointer, ref status);
        });
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter() 
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
            if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter() 
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0) {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try {
            action(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {   
        IncrementCallCounter();
        try {
            return func(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    
    public String AsString() {
        return CallWithPointer(thisPtr => FfiConverterString.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_name_as_string(thisPtr,  ref _status)
)));
    }
    
    
    /// <summary>
    /// Get the name components as a vector of strings
    /// </summary>
    public List<String> Components() {
        return CallWithPointer(thisPtr => FfiConverterSequenceString.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_name_components(thisPtr,  ref _status)
)));
    }
    
    
    /// <summary>
    /// Get the name ID
    /// </summary>
    public ulong Id() {
        return CallWithPointer(thisPtr => FfiConverterUInt64.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_name_id(thisPtr,  ref _status)
)));
    }
    
    

    
    /// <summary>
    /// Create a new Name from components with an ID
    /// </summary>
    public static Name NewWithId(String @component0, String @component1, String @component2, ulong @id) {
        return new Name(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_constructor_name_new_with_id(FfiConverterString.INSTANCE.Lower(@component0), FfiConverterString.INSTANCE.Lower(@component1), FfiConverterString.INSTANCE.Lower(@component2), FfiConverterUInt64.INSTANCE.Lower(@id), ref _status)
));
    }
    
    
}
class FfiConverterTypeName: FfiConverter<Name, IntPtr> {
    public static FfiConverterTypeName INSTANCE = new FfiConverterTypeName();


    public override IntPtr Lower(Name value) {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override Name Lift(IntPtr value) {
        return new Name(value);
    }

    public override Name Read(BigEndianStream stream) {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(Name value) {
        return 8;
    }

    public override void Write(Name value, BigEndianStream stream) {
        stream.WriteLong(Lower(value).ToInt64());
    }
}



/// <summary>
/// Service wrapper for uniffi bindings
/// </summary>
internal interface IService {
    /// <summary>
    /// Get the service configuration
    /// </summary>
    ServiceConfig Config();
    /// <summary>
    /// Connect to a remote endpoint as a client - blocking version
    /// </summary>
    /// <exception cref="SlimException"></exception>
    ulong Connect(ClientConfig @config);
    /// <summary>
    /// Connect to a remote endpoint as a client
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task<ulong> ConnectAsync(ClientConfig @config);
    /// <summary>
    /// Create a new App with authentication configuration (blocking version)
    ///
    /// This method initializes authentication providers/verifiers and creates a App
    /// on this service instance. This is a blocking wrapper around create_app_async.
    ///
    /// # Arguments
    /// * `base_name` - The base name for the app (without ID)
    /// * `identity_provider_config` - Configuration for proving identity to others
    /// * `identity_verifier_config` - Configuration for verifying identity of others
    ///
    /// # Returns
    /// * `Ok(Arc<App>)` - Successfully created adapter
    /// * `Err(SlimError)` - If adapter creation fails
    /// </summary>
    /// <exception cref="SlimException"></exception>
    App CreateApp(Name @baseName, IdentityProviderConfig @identityProviderConfig, IdentityVerifierConfig @identityVerifierConfig);
    /// <summary>
    /// Create a new App with authentication configuration (async version)
    ///
    /// This method initializes authentication providers/verifiers and creates a App
    /// on this service instance.
    ///
    /// # Arguments
    /// * `base_name` - The base name for the app (without ID)
    /// * `identity_provider_config` - Configuration for proving identity to others
    /// * `identity_verifier_config` - Configuration for verifying identity of others
    ///
    /// # Returns
    /// * `Ok(Arc<App>)` - Successfully created adapter
    /// * `Err(SlimError)` - If adapter creation fails
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task<App> CreateAppAsync(Name @baseName, IdentityProviderConfig @identityProviderConfig, IdentityVerifierConfig @identityVerifierConfig);
    /// <summary>
    /// Create a new App with SharedSecret authentication (helper function)
    ///
    /// This is a convenience function for creating a SLIM application using SharedSecret authentication
    /// on this service instance.
    ///
    /// # Arguments
    /// * `name` - The base name for the app (without ID)
    /// * `secret` - The shared secret string for authentication
    ///
    /// # Returns
    /// * `Ok(Arc<App>)` - Successfully created app
    /// * `Err(SlimError)` - If app creation fails
    /// </summary>
    /// <exception cref="SlimException"></exception>
    App CreateAppWithSecret(Name @name, String @secret);
    /// <summary>
    /// Create a new App with SharedSecret authentication (async version)
    ///
    /// This is a convenience function for creating a SLIM application using SharedSecret authentication
    /// on this service instance. This is the async version.
    ///
    /// # Arguments
    /// * `name` - The base name for the app (without ID)
    /// * `secret` - The shared secret string for authentication
    ///
    /// # Returns
    /// * `Ok(Arc<App>)` - Successfully created app
    /// * `Err(SlimError)` - If app creation fails
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task<App> CreateAppWithSecretAsync(Name @name, String @secret);
    /// <summary>
    /// Disconnect a client connection by connection ID - blocking version
    /// </summary>
    /// <exception cref="SlimException"></exception>
    void Disconnect(ulong @connId);
    /// <summary>
    /// Get the connection ID for a given endpoint
    /// </summary>
    ulong? GetConnectionId(String @endpoint);
    /// <summary>
    /// Get the service identifier/name
    /// </summary>
    String GetName();
    /// <summary>
    /// Run the service (starts all configured servers and clients) - blocking version
    /// </summary>
    /// <exception cref="SlimException"></exception>
    void Run();
    /// <summary>
    /// Run the service (starts all configured servers and clients)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task RunAsync();
    /// <summary>
    /// Start a server with the given configuration - blocking version
    /// </summary>
    /// <exception cref="SlimException"></exception>
    void RunServer(ServerConfig @config);
    /// <summary>
    /// Start a server with the given configuration
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task RunServerAsync(ServerConfig @config);
    /// <summary>
    /// Shutdown the service gracefully - blocking version
    /// </summary>
    /// <exception cref="SlimException"></exception>
    void Shutdown();
    /// <summary>
    /// Shutdown the service gracefully
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task ShutdownAsync();
    /// <summary>
    /// Stop a server by endpoint - blocking version
    /// </summary>
    /// <exception cref="SlimException"></exception>
    void StopServer(String @endpoint);
}
/// <summary>
/// Service wrapper for uniffi bindings
/// </summary>
internal class Service : IService, IDisposable {
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public Service(IntPtr pointer) {
        this.pointer = pointer;
    }

    ~Service() {
        Destroy();
    }
    /// <summary>
    /// Create a new Service with the given name
    /// </summary>
    public Service(String @name) :
        this(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_constructor_service_new(FfiConverterString.INSTANCE.Lower(@name), ref _status)
)) {}

    protected void FreeRustArcPtr() {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.uniffi_slim_bindings_fn_free_service(this.pointer, ref status);
        });
    }

    protected IntPtr CloneRustArcPtr() {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            return _UniFFILib.uniffi_slim_bindings_fn_clone_service(this.pointer, ref status);
        });
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter() 
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
            if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter() 
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0) {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try {
            action(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {   
        IncrementCallCounter();
        try {
            return func(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    
    /// <summary>
    /// Get the service configuration
    /// </summary>
    public ServiceConfig Config() {
        return CallWithPointer(thisPtr => FfiConverterTypeServiceConfig.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_service_config(thisPtr,  ref _status)
)));
    }
    
    
    /// <summary>
    /// Connect to a remote endpoint as a client - blocking version
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public ulong Connect(ClientConfig @config) {
        return CallWithPointer(thisPtr => FfiConverterUInt64.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_service_connect(thisPtr, FfiConverterTypeClientConfig.INSTANCE.Lower(@config), ref _status)
)));
    }
    
    
    /// <summary>
    /// Connect to a remote endpoint as a client
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task<ulong> ConnectAsync(ClientConfig @config) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_service_connect_async(thisPtr, FfiConverterTypeClientConfig.INSTANCE.Lower(@config));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_u64(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_slim_bindings_rust_future_complete_u64(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_u64(future),
        // Lift
        (result) => FfiConverterUInt64.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Create a new App with authentication configuration (blocking version)
    ///
    /// This method initializes authentication providers/verifiers and creates a App
    /// on this service instance. This is a blocking wrapper around create_app_async.
    ///
    /// # Arguments
    /// * `base_name` - The base name for the app (without ID)
    /// * `identity_provider_config` - Configuration for proving identity to others
    /// * `identity_verifier_config` - Configuration for verifying identity of others
    ///
    /// # Returns
    /// * `Ok(Arc<App>)` - Successfully created adapter
    /// * `Err(SlimError)` - If adapter creation fails
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public App CreateApp(Name @baseName, IdentityProviderConfig @identityProviderConfig, IdentityVerifierConfig @identityVerifierConfig) {
        return CallWithPointer(thisPtr => FfiConverterTypeApp.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_service_create_app(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@baseName), FfiConverterTypeIdentityProviderConfig.INSTANCE.Lower(@identityProviderConfig), FfiConverterTypeIdentityVerifierConfig.INSTANCE.Lower(@identityVerifierConfig), ref _status)
)));
    }
    
    
    /// <summary>
    /// Create a new App with authentication configuration (async version)
    ///
    /// This method initializes authentication providers/verifiers and creates a App
    /// on this service instance.
    ///
    /// # Arguments
    /// * `base_name` - The base name for the app (without ID)
    /// * `identity_provider_config` - Configuration for proving identity to others
    /// * `identity_verifier_config` - Configuration for verifying identity of others
    ///
    /// # Returns
    /// * `Ok(Arc<App>)` - Successfully created adapter
    /// * `Err(SlimError)` - If adapter creation fails
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task<App> CreateAppAsync(Name @baseName, IdentityProviderConfig @identityProviderConfig, IdentityVerifierConfig @identityVerifierConfig) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_service_create_app_async(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@baseName), FfiConverterTypeIdentityProviderConfig.INSTANCE.Lower(@identityProviderConfig), FfiConverterTypeIdentityVerifierConfig.INSTANCE.Lower(@identityVerifierConfig));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_pointer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_slim_bindings_rust_future_complete_pointer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_pointer(future),
        // Lift
        (result) => FfiConverterTypeApp.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Create a new App with SharedSecret authentication (helper function)
    ///
    /// This is a convenience function for creating a SLIM application using SharedSecret authentication
    /// on this service instance.
    ///
    /// # Arguments
    /// * `name` - The base name for the app (without ID)
    /// * `secret` - The shared secret string for authentication
    ///
    /// # Returns
    /// * `Ok(Arc<App>)` - Successfully created app
    /// * `Err(SlimError)` - If app creation fails
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public App CreateAppWithSecret(Name @name, String @secret) {
        return CallWithPointer(thisPtr => FfiConverterTypeApp.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_service_create_app_with_secret(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@name), FfiConverterString.INSTANCE.Lower(@secret), ref _status)
)));
    }
    
    
    /// <summary>
    /// Create a new App with SharedSecret authentication (async version)
    ///
    /// This is a convenience function for creating a SLIM application using SharedSecret authentication
    /// on this service instance. This is the async version.
    ///
    /// # Arguments
    /// * `name` - The base name for the app (without ID)
    /// * `secret` - The shared secret string for authentication
    ///
    /// # Returns
    /// * `Ok(Arc<App>)` - Successfully created app
    /// * `Err(SlimError)` - If app creation fails
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task<App> CreateAppWithSecretAsync(Name @name, String @secret) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_service_create_app_with_secret_async(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@name), FfiConverterString.INSTANCE.Lower(@secret));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_pointer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_slim_bindings_rust_future_complete_pointer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_pointer(future),
        // Lift
        (result) => FfiConverterTypeApp.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Disconnect a client connection by connection ID - blocking version
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public void Disconnect(ulong @connId) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_service_disconnect(thisPtr, FfiConverterUInt64.INSTANCE.Lower(@connId), ref _status)
));
    }
    
    
    
    /// <summary>
    /// Get the connection ID for a given endpoint
    /// </summary>
    public ulong? GetConnectionId(String @endpoint) {
        return CallWithPointer(thisPtr => FfiConverterOptionalUInt64.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_service_get_connection_id(thisPtr, FfiConverterString.INSTANCE.Lower(@endpoint), ref _status)
)));
    }
    
    
    /// <summary>
    /// Get the service identifier/name
    /// </summary>
    public String GetName() {
        return CallWithPointer(thisPtr => FfiConverterString.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_service_get_name(thisPtr,  ref _status)
)));
    }
    
    
    /// <summary>
    /// Run the service (starts all configured servers and clients) - blocking version
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public void Run() {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_service_run(thisPtr,  ref _status)
));
    }
    
    
    
    /// <summary>
    /// Run the service (starts all configured servers and clients)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task RunAsync() {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_service_run_async(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_slim_bindings_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_void(future),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Start a server with the given configuration - blocking version
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public void RunServer(ServerConfig @config) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_service_run_server(thisPtr, FfiConverterTypeServerConfig.INSTANCE.Lower(@config), ref _status)
));
    }
    
    
    
    /// <summary>
    /// Start a server with the given configuration
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task RunServerAsync(ServerConfig @config) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_service_run_server_async(thisPtr, FfiConverterTypeServerConfig.INSTANCE.Lower(@config));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_slim_bindings_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_void(future),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Shutdown the service gracefully - blocking version
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public void Shutdown() {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_service_shutdown(thisPtr,  ref _status)
));
    }
    
    
    
    /// <summary>
    /// Shutdown the service gracefully
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task ShutdownAsync() {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_service_shutdown_async(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_slim_bindings_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_void(future),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Stop a server by endpoint - blocking version
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public void StopServer(String @endpoint) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_service_stop_server(thisPtr, FfiConverterString.INSTANCE.Lower(@endpoint), ref _status)
));
    }
    
    
    

    
    /// <summary>
    /// Create a new Service with configuration
    /// </summary>
    public static Service NewWithConfig(String @name, ServiceConfig @config) {
        return new Service(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_constructor_service_new_with_config(FfiConverterString.INSTANCE.Lower(@name), FfiConverterTypeServiceConfig.INSTANCE.Lower(@config), ref _status)
));
    }
    
    
}
class FfiConverterTypeService: FfiConverter<Service, IntPtr> {
    public static FfiConverterTypeService INSTANCE = new FfiConverterTypeService();


    public override IntPtr Lower(Service value) {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override Service Lift(IntPtr value) {
        return new Service(value);
    }

    public override Service Read(BigEndianStream stream) {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(Service value) {
        return 8;
    }

    public override void Write(Service value, BigEndianStream stream) {
        stream.WriteLong(Lower(value).ToInt64());
    }
}



/// <summary>
/// Session context for language bindings (UniFFI-compatible)
///
/// Wraps the session context with proper async access patterns for message reception.
/// Provides both synchronous (blocking) and asynchronous methods for FFI compatibility.
/// </summary>
internal interface ISession {
    /// <summary>
    /// Get the session configuration
    /// </summary>
    /// <exception cref="SlimException"></exception>
    SessionConfig Config();
    /// <summary>
    /// Get the destination name for this session
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Name Destination();
    /// <summary>
    /// Receive a message from the session (blocking version for FFI)
    ///
    /// # Arguments
    /// * `timeout` - Optional timeout duration
    ///
    /// # Returns
    /// * `Ok(ReceivedMessage)` - Message with context and payload bytes
    /// * `Err(SlimError)` - If the receive fails or times out
    /// </summary>
    /// <exception cref="SlimException"></exception>
    ReceivedMessage GetMessage(TimeSpan? @timeout);
    /// <summary>
    /// Receive a message from the session (async version)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task<ReceivedMessage> GetMessageAsync(TimeSpan? @timeout);
    /// <summary>
    /// Invite a participant to the session (blocking version)
    ///
    /// Returns a completion handle that can be awaited to ensure the invitation completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    CompletionHandle Invite(Name @participant);
    /// <summary>
    /// Invite a participant and wait for completion (blocking version)
    ///
    /// This method invites a participant and blocks until the invitation completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    void InviteAndWait(Name @participant);
    /// <summary>
    /// Invite a participant and wait for completion (async version)
    ///
    /// This method invites a participant and waits until the invitation completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task InviteAndWaitAsync(Name @participant);
    /// <summary>
    /// Invite a participant to the session (async version)
    ///
    /// Returns a completion handle that can be awaited to ensure the invitation completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task<CompletionHandle> InviteAsync(Name @participant);
    /// <summary>
    /// Check if this session is the initiator
    /// </summary>
    /// <exception cref="SlimException"></exception>
    bool IsInitiator();
    /// <summary>
    /// Get the session metadata
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Dictionary<String, String> Metadata();
    /// <summary>
    /// Get list of participants in the session (blocking version for FFI)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    List<Name> ParticipantsList();
    /// <summary>
    /// Get list of participants in the session
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task<List<Name>> ParticipantsListAsync();
    /// <summary>
    /// Publish a message to the session's destination (blocking version)
    ///
    /// Returns a completion handle that can be awaited to ensure the message was delivered.
    ///
    /// # Arguments
    /// * `data` - The message payload bytes
    /// * `payload_type` - Optional content type identifier
    /// * `metadata` - Optional key-value metadata pairs
    ///
    /// # Returns
    /// * `Ok(CompletionHandle)` - Handle to await delivery confirmation
    /// * `Err(SlimError)` - If publishing fails
    ///
    /// # Example
    /// ```ignore
    /// let completion = session.publish(data, None, None)?;
    /// completion.wait()?; // Blocks until message is delivered
    /// ```
    /// </summary>
    /// <exception cref="SlimException"></exception>
    CompletionHandle Publish(byte[] @data, String? @payloadType, Dictionary<String, String>? @metadata);
    /// <summary>
    /// Publish a message and wait for completion (blocking version)
    ///
    /// This method publishes a message and blocks until the delivery completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    void PublishAndWait(byte[] @data, String? @payloadType, Dictionary<String, String>? @metadata);
    /// <summary>
    /// Publish a message and wait for completion (async version)
    ///
    /// This method publishes a message and waits until the delivery completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task PublishAndWaitAsync(byte[] @data, String? @payloadType, Dictionary<String, String>? @metadata);
    /// <summary>
    /// Publish a message to the session's destination (async version)
    ///
    /// Returns a completion handle that can be awaited to ensure the message was delivered.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task<CompletionHandle> PublishAsync(byte[] @data, String? @payloadType, Dictionary<String, String>? @metadata);
    /// <summary>
    /// Publish a reply message to the originator of a received message (blocking version for FFI)
    ///
    /// This method uses the routing information from a previously received message
    /// to send a reply back to the sender. This is the preferred way to implement
    /// request/reply patterns.
    ///
    /// Returns a completion handle that can be awaited to ensure the message was delivered.
    ///
    /// # Arguments
    /// * `message_context` - Context from a message received via `get_message()`
    /// * `data` - The reply payload bytes
    /// * `payload_type` - Optional content type identifier
    /// * `metadata` - Optional key-value metadata pairs
    ///
    /// # Returns
    /// * `Ok(CompletionHandle)` - Handle to await delivery confirmation
    /// * `Err(SlimError)` - If publishing fails
    /// </summary>
    /// <exception cref="SlimException"></exception>
    CompletionHandle PublishTo(MessageContext @messageContext, byte[] @data, String? @payloadType, Dictionary<String, String>? @metadata);
    /// <summary>
    /// Publish a reply message and wait for completion (blocking version)
    ///
    /// This method publishes a reply to a received message and blocks until the delivery completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    void PublishToAndWait(MessageContext @messageContext, byte[] @data, String? @payloadType, Dictionary<String, String>? @metadata);
    /// <summary>
    /// Publish a reply message and wait for completion (async version)
    ///
    /// This method publishes a reply to a received message and waits until the delivery completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task PublishToAndWaitAsync(MessageContext @messageContext, byte[] @data, String? @payloadType, Dictionary<String, String>? @metadata);
    /// <summary>
    /// Publish a reply message (async version)
    ///
    /// Returns a completion handle that can be awaited to ensure the message was delivered.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task<CompletionHandle> PublishToAsync(MessageContext @messageContext, byte[] @data, String? @payloadType, Dictionary<String, String>? @metadata);
    /// <summary>
    /// Low-level publish with full control over all parameters (blocking version for FFI)
    ///
    /// This is an advanced method that provides complete control over routing and delivery.
    /// Most users should use `publish()` or `publish_to()` instead.
    ///
    /// # Arguments
    /// * `destination` - Target name to send to
    /// * `fanout` - Number of copies to send (for multicast)
    /// * `data` - The message payload bytes
    /// * `connection_out` - Optional specific connection ID to use
    /// * `payload_type` - Optional content type identifier
    /// * `metadata` - Optional key-value metadata pairs
    /// </summary>
    /// <exception cref="SlimException"></exception>
    void PublishWithParams(Name @destination, uint @fanout, byte[] @data, ulong? @connectionOut, String? @payloadType, Dictionary<String, String>? @metadata);
    /// <summary>
    /// Low-level publish with full control (async version)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task PublishWithParamsAsync(Name @destination, uint @fanout, byte[] @data, ulong? @connectionOut, String? @payloadType, Dictionary<String, String>? @metadata);
    /// <summary>
    /// Remove a participant from the session (blocking version)
    ///
    /// Returns a completion handle that can be awaited to ensure the removal completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    CompletionHandle Remove(Name @participant);
    /// <summary>
    /// Remove a participant and wait for completion (blocking version)
    ///
    /// This method removes a participant and blocks until the removal completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    void RemoveAndWait(Name @participant);
    /// <summary>
    /// Remove a participant and wait for completion (async version)
    ///
    /// This method removes a participant and waits until the removal completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task RemoveAndWaitAsync(Name @participant);
    /// <summary>
    /// Remove a participant from the session (async version)
    ///
    /// Returns a completion handle that can be awaited to ensure the removal completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Task<CompletionHandle> RemoveAsync(Name @participant);
    /// <summary>
    /// Get the session ID
    /// </summary>
    /// <exception cref="SlimException"></exception>
    uint SessionId();
    /// <summary>
    /// Get the session type (PointToPoint or Group)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    SessionType SessionType();
    /// <summary>
    /// Get the source name for this session
    /// </summary>
    /// <exception cref="SlimException"></exception>
    Name Source();
}
/// <summary>
/// Session context for language bindings (UniFFI-compatible)
///
/// Wraps the session context with proper async access patterns for message reception.
/// Provides both synchronous (blocking) and asynchronous methods for FFI compatibility.
/// </summary>
internal class Session : ISession, IDisposable {
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public Session(IntPtr pointer) {
        this.pointer = pointer;
    }

    ~Session() {
        Destroy();
    }

    protected void FreeRustArcPtr() {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.uniffi_slim_bindings_fn_free_session(this.pointer, ref status);
        });
    }

    protected IntPtr CloneRustArcPtr() {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            return _UniFFILib.uniffi_slim_bindings_fn_clone_session(this.pointer, ref status);
        });
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter() 
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
            if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter() 
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0) {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try {
            action(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {   
        IncrementCallCounter();
        try {
            return func(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    
    /// <summary>
    /// Get the session configuration
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public SessionConfig Config() {
        return CallWithPointer(thisPtr => FfiConverterTypeSessionConfig.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_session_config(thisPtr,  ref _status)
)));
    }
    
    
    /// <summary>
    /// Get the destination name for this session
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public Name Destination() {
        return CallWithPointer(thisPtr => FfiConverterTypeName.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_session_destination(thisPtr,  ref _status)
)));
    }
    
    
    /// <summary>
    /// Receive a message from the session (blocking version for FFI)
    ///
    /// # Arguments
    /// * `timeout` - Optional timeout duration
    ///
    /// # Returns
    /// * `Ok(ReceivedMessage)` - Message with context and payload bytes
    /// * `Err(SlimError)` - If the receive fails or times out
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public ReceivedMessage GetMessage(TimeSpan? @timeout) {
        return CallWithPointer(thisPtr => FfiConverterTypeReceivedMessage.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_session_get_message(thisPtr, FfiConverterOptionalDuration.INSTANCE.Lower(@timeout), ref _status)
)));
    }
    
    
    /// <summary>
    /// Receive a message from the session (async version)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task<ReceivedMessage> GetMessageAsync(TimeSpan? @timeout) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_session_get_message_async(thisPtr, FfiConverterOptionalDuration.INSTANCE.Lower(@timeout));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_slim_bindings_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeReceivedMessage.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Invite a participant to the session (blocking version)
    ///
    /// Returns a completion handle that can be awaited to ensure the invitation completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public CompletionHandle Invite(Name @participant) {
        return CallWithPointer(thisPtr => FfiConverterTypeCompletionHandle.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_session_invite(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@participant), ref _status)
)));
    }
    
    
    /// <summary>
    /// Invite a participant and wait for completion (blocking version)
    ///
    /// This method invites a participant and blocks until the invitation completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public void InviteAndWait(Name @participant) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_session_invite_and_wait(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@participant), ref _status)
));
    }
    
    
    
    /// <summary>
    /// Invite a participant and wait for completion (async version)
    ///
    /// This method invites a participant and waits until the invitation completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task InviteAndWaitAsync(Name @participant) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_session_invite_and_wait_async(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@participant));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_slim_bindings_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_void(future),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Invite a participant to the session (async version)
    ///
    /// Returns a completion handle that can be awaited to ensure the invitation completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task<CompletionHandle> InviteAsync(Name @participant) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_session_invite_async(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@participant));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_pointer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_slim_bindings_rust_future_complete_pointer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_pointer(future),
        // Lift
        (result) => FfiConverterTypeCompletionHandle.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Check if this session is the initiator
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public bool IsInitiator() {
        return CallWithPointer(thisPtr => FfiConverterBoolean.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_session_is_initiator(thisPtr,  ref _status)
)));
    }
    
    
    /// <summary>
    /// Get the session metadata
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public Dictionary<String, String> Metadata() {
        return CallWithPointer(thisPtr => FfiConverterDictionaryStringString.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_session_metadata(thisPtr,  ref _status)
)));
    }
    
    
    /// <summary>
    /// Get list of participants in the session (blocking version for FFI)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public List<Name> ParticipantsList() {
        return CallWithPointer(thisPtr => FfiConverterSequenceTypeName.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_session_participants_list(thisPtr,  ref _status)
)));
    }
    
    
    /// <summary>
    /// Get list of participants in the session
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task<List<Name>> ParticipantsListAsync() {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_session_participants_list_async(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_slim_bindings_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterSequenceTypeName.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Publish a message to the session's destination (blocking version)
    ///
    /// Returns a completion handle that can be awaited to ensure the message was delivered.
    ///
    /// # Arguments
    /// * `data` - The message payload bytes
    /// * `payload_type` - Optional content type identifier
    /// * `metadata` - Optional key-value metadata pairs
    ///
    /// # Returns
    /// * `Ok(CompletionHandle)` - Handle to await delivery confirmation
    /// * `Err(SlimError)` - If publishing fails
    ///
    /// # Example
    /// ```ignore
    /// let completion = session.publish(data, None, None)?;
    /// completion.wait()?; // Blocks until message is delivered
    /// ```
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public CompletionHandle Publish(byte[] @data, String? @payloadType, Dictionary<String, String>? @metadata) {
        return CallWithPointer(thisPtr => FfiConverterTypeCompletionHandle.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_session_publish(thisPtr, FfiConverterByteArray.INSTANCE.Lower(@data), FfiConverterOptionalString.INSTANCE.Lower(@payloadType), FfiConverterOptionalDictionaryStringString.INSTANCE.Lower(@metadata), ref _status)
)));
    }
    
    
    /// <summary>
    /// Publish a message and wait for completion (blocking version)
    ///
    /// This method publishes a message and blocks until the delivery completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public void PublishAndWait(byte[] @data, String? @payloadType, Dictionary<String, String>? @metadata) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_session_publish_and_wait(thisPtr, FfiConverterByteArray.INSTANCE.Lower(@data), FfiConverterOptionalString.INSTANCE.Lower(@payloadType), FfiConverterOptionalDictionaryStringString.INSTANCE.Lower(@metadata), ref _status)
));
    }
    
    
    
    /// <summary>
    /// Publish a message and wait for completion (async version)
    ///
    /// This method publishes a message and waits until the delivery completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task PublishAndWaitAsync(byte[] @data, String? @payloadType, Dictionary<String, String>? @metadata) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_session_publish_and_wait_async(thisPtr, FfiConverterByteArray.INSTANCE.Lower(@data), FfiConverterOptionalString.INSTANCE.Lower(@payloadType), FfiConverterOptionalDictionaryStringString.INSTANCE.Lower(@metadata));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_slim_bindings_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_void(future),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Publish a message to the session's destination (async version)
    ///
    /// Returns a completion handle that can be awaited to ensure the message was delivered.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task<CompletionHandle> PublishAsync(byte[] @data, String? @payloadType, Dictionary<String, String>? @metadata) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_session_publish_async(thisPtr, FfiConverterByteArray.INSTANCE.Lower(@data), FfiConverterOptionalString.INSTANCE.Lower(@payloadType), FfiConverterOptionalDictionaryStringString.INSTANCE.Lower(@metadata));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_pointer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_slim_bindings_rust_future_complete_pointer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_pointer(future),
        // Lift
        (result) => FfiConverterTypeCompletionHandle.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Publish a reply message to the originator of a received message (blocking version for FFI)
    ///
    /// This method uses the routing information from a previously received message
    /// to send a reply back to the sender. This is the preferred way to implement
    /// request/reply patterns.
    ///
    /// Returns a completion handle that can be awaited to ensure the message was delivered.
    ///
    /// # Arguments
    /// * `message_context` - Context from a message received via `get_message()`
    /// * `data` - The reply payload bytes
    /// * `payload_type` - Optional content type identifier
    /// * `metadata` - Optional key-value metadata pairs
    ///
    /// # Returns
    /// * `Ok(CompletionHandle)` - Handle to await delivery confirmation
    /// * `Err(SlimError)` - If publishing fails
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public CompletionHandle PublishTo(MessageContext @messageContext, byte[] @data, String? @payloadType, Dictionary<String, String>? @metadata) {
        return CallWithPointer(thisPtr => FfiConverterTypeCompletionHandle.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_session_publish_to(thisPtr, FfiConverterTypeMessageContext.INSTANCE.Lower(@messageContext), FfiConverterByteArray.INSTANCE.Lower(@data), FfiConverterOptionalString.INSTANCE.Lower(@payloadType), FfiConverterOptionalDictionaryStringString.INSTANCE.Lower(@metadata), ref _status)
)));
    }
    
    
    /// <summary>
    /// Publish a reply message and wait for completion (blocking version)
    ///
    /// This method publishes a reply to a received message and blocks until the delivery completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public void PublishToAndWait(MessageContext @messageContext, byte[] @data, String? @payloadType, Dictionary<String, String>? @metadata) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_session_publish_to_and_wait(thisPtr, FfiConverterTypeMessageContext.INSTANCE.Lower(@messageContext), FfiConverterByteArray.INSTANCE.Lower(@data), FfiConverterOptionalString.INSTANCE.Lower(@payloadType), FfiConverterOptionalDictionaryStringString.INSTANCE.Lower(@metadata), ref _status)
));
    }
    
    
    
    /// <summary>
    /// Publish a reply message and wait for completion (async version)
    ///
    /// This method publishes a reply to a received message and waits until the delivery completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task PublishToAndWaitAsync(MessageContext @messageContext, byte[] @data, String? @payloadType, Dictionary<String, String>? @metadata) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_session_publish_to_and_wait_async(thisPtr, FfiConverterTypeMessageContext.INSTANCE.Lower(@messageContext), FfiConverterByteArray.INSTANCE.Lower(@data), FfiConverterOptionalString.INSTANCE.Lower(@payloadType), FfiConverterOptionalDictionaryStringString.INSTANCE.Lower(@metadata));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_slim_bindings_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_void(future),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Publish a reply message (async version)
    ///
    /// Returns a completion handle that can be awaited to ensure the message was delivered.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task<CompletionHandle> PublishToAsync(MessageContext @messageContext, byte[] @data, String? @payloadType, Dictionary<String, String>? @metadata) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_session_publish_to_async(thisPtr, FfiConverterTypeMessageContext.INSTANCE.Lower(@messageContext), FfiConverterByteArray.INSTANCE.Lower(@data), FfiConverterOptionalString.INSTANCE.Lower(@payloadType), FfiConverterOptionalDictionaryStringString.INSTANCE.Lower(@metadata));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_pointer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_slim_bindings_rust_future_complete_pointer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_pointer(future),
        // Lift
        (result) => FfiConverterTypeCompletionHandle.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Low-level publish with full control over all parameters (blocking version for FFI)
    ///
    /// This is an advanced method that provides complete control over routing and delivery.
    /// Most users should use `publish()` or `publish_to()` instead.
    ///
    /// # Arguments
    /// * `destination` - Target name to send to
    /// * `fanout` - Number of copies to send (for multicast)
    /// * `data` - The message payload bytes
    /// * `connection_out` - Optional specific connection ID to use
    /// * `payload_type` - Optional content type identifier
    /// * `metadata` - Optional key-value metadata pairs
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public void PublishWithParams(Name @destination, uint @fanout, byte[] @data, ulong? @connectionOut, String? @payloadType, Dictionary<String, String>? @metadata) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_session_publish_with_params(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@destination), FfiConverterUInt32.INSTANCE.Lower(@fanout), FfiConverterByteArray.INSTANCE.Lower(@data), FfiConverterOptionalUInt64.INSTANCE.Lower(@connectionOut), FfiConverterOptionalString.INSTANCE.Lower(@payloadType), FfiConverterOptionalDictionaryStringString.INSTANCE.Lower(@metadata), ref _status)
));
    }
    
    
    
    /// <summary>
    /// Low-level publish with full control (async version)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task PublishWithParamsAsync(Name @destination, uint @fanout, byte[] @data, ulong? @connectionOut, String? @payloadType, Dictionary<String, String>? @metadata) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_session_publish_with_params_async(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@destination), FfiConverterUInt32.INSTANCE.Lower(@fanout), FfiConverterByteArray.INSTANCE.Lower(@data), FfiConverterOptionalUInt64.INSTANCE.Lower(@connectionOut), FfiConverterOptionalString.INSTANCE.Lower(@payloadType), FfiConverterOptionalDictionaryStringString.INSTANCE.Lower(@metadata));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_slim_bindings_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_void(future),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Remove a participant from the session (blocking version)
    ///
    /// Returns a completion handle that can be awaited to ensure the removal completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public CompletionHandle Remove(Name @participant) {
        return CallWithPointer(thisPtr => FfiConverterTypeCompletionHandle.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_session_remove(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@participant), ref _status)
)));
    }
    
    
    /// <summary>
    /// Remove a participant and wait for completion (blocking version)
    ///
    /// This method removes a participant and blocks until the removal completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public void RemoveAndWait(Name @participant) {
        CallWithPointer(thisPtr =>
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_session_remove_and_wait(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@participant), ref _status)
));
    }
    
    
    
    /// <summary>
    /// Remove a participant and wait for completion (async version)
    ///
    /// This method removes a participant and waits until the removal completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task RemoveAndWaitAsync(Name @participant) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_session_remove_and_wait_async(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@participant));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_slim_bindings_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_void(future),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Remove a participant from the session (async version)
    ///
    /// Returns a completion handle that can be awaited to ensure the removal completes.
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public async Task<CompletionHandle> RemoveAsync(Name @participant) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_slim_bindings_fn_method_session_remove_async(thisPtr, FfiConverterTypeName.INSTANCE.Lower(@participant));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_slim_bindings_rust_future_poll_pointer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_slim_bindings_rust_future_complete_pointer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_slim_bindings_rust_future_free_pointer(future),
        // Lift
        (result) => FfiConverterTypeCompletionHandle.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSlimError.INSTANCE
    );
    }
    
    /// <summary>
    /// Get the session ID
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public uint SessionId() {
        return CallWithPointer(thisPtr => FfiConverterUInt32.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_session_session_id(thisPtr,  ref _status)
)));
    }
    
    
    /// <summary>
    /// Get the session type (PointToPoint or Group)
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public SessionType SessionType() {
        return CallWithPointer(thisPtr => FfiConverterTypeSessionType.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_session_session_type(thisPtr,  ref _status)
)));
    }
    
    
    /// <summary>
    /// Get the source name for this session
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public Name Source() {
        return CallWithPointer(thisPtr => FfiConverterTypeName.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_method_session_source(thisPtr,  ref _status)
)));
    }
    
    

    
}
class FfiConverterTypeSession: FfiConverter<Session, IntPtr> {
    public static FfiConverterTypeSession INSTANCE = new FfiConverterTypeSession();


    public override IntPtr Lower(Session value) {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override Session Lift(IntPtr value) {
        return new Session(value);
    }

    public override Session Read(BigEndianStream stream) {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(Session value) {
        return 8;
    }

    public override void Write(Session value, BigEndianStream stream) {
        stream.WriteLong(Lower(value).ToInt64());
    }
}



/// <summary>
/// Basic authentication configuration
/// </summary>
internal record BasicAuth (
    String @username, 
    String @password
) {
}

class FfiConverterTypeBasicAuth: FfiConverterRustBuffer<BasicAuth> {
    public static FfiConverterTypeBasicAuth INSTANCE = new FfiConverterTypeBasicAuth();

    public override BasicAuth Read(BigEndianStream stream) {
        return new BasicAuth(
            @username: FfiConverterString.INSTANCE.Read(stream),
            @password: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(BasicAuth value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@username)
            + FfiConverterString.INSTANCE.AllocationSize(value.@password);
    }

    public override void Write(BasicAuth value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@username, stream);
            FfiConverterString.INSTANCE.Write(value.@password, stream);
    }
}



/// <summary>
/// Build information for the SLIM bindings
/// </summary>
/// <param name="version">
/// Semantic version (e.g., "0.7.0")
/// </param>
/// <param name="git_sha">
/// Git commit hash (short)
/// </param>
/// <param name="build_date">
/// Build date in ISO 8601 UTC format
/// </param>
/// <param name="profile">
/// Build profile (debug/release)
/// </param>
internal record BuildInfo (
    /// <summary>
    /// Semantic version (e.g., "0.7.0")
    /// </summary>
    String @version, 
    /// <summary>
    /// Git commit hash (short)
    /// </summary>
    String @gitSha, 
    /// <summary>
    /// Build date in ISO 8601 UTC format
    /// </summary>
    String @buildDate, 
    /// <summary>
    /// Build profile (debug/release)
    /// </summary>
    String @profile
) {
}

class FfiConverterTypeBuildInfo: FfiConverterRustBuffer<BuildInfo> {
    public static FfiConverterTypeBuildInfo INSTANCE = new FfiConverterTypeBuildInfo();

    public override BuildInfo Read(BigEndianStream stream) {
        return new BuildInfo(
            @version: FfiConverterString.INSTANCE.Read(stream),
            @gitSha: FfiConverterString.INSTANCE.Read(stream),
            @buildDate: FfiConverterString.INSTANCE.Read(stream),
            @profile: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(BuildInfo value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@version)
            + FfiConverterString.INSTANCE.AllocationSize(value.@gitSha)
            + FfiConverterString.INSTANCE.AllocationSize(value.@buildDate)
            + FfiConverterString.INSTANCE.AllocationSize(value.@profile);
    }

    public override void Write(BuildInfo value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@version, stream);
            FfiConverterString.INSTANCE.Write(value.@gitSha, stream);
            FfiConverterString.INSTANCE.Write(value.@buildDate, stream);
            FfiConverterString.INSTANCE.Write(value.@profile, stream);
    }
}



/// <summary>
/// Client configuration for connecting to a SLIM server
/// </summary>
/// <param name="endpoint">
/// The target endpoint the client will connect to
/// </param>
/// <param name="origin">
/// Origin (HTTP Host authority override) for the client
/// </param>
/// <param name="server_name">
/// Optional TLS SNI server name override
/// </param>
/// <param name="compression">
/// Compression type
/// </param>
/// <param name="rate_limit">
/// Rate limit string (e.g., "100/s" for 100 requests per second)
/// </param>
/// <param name="tls">
/// TLS client configuration
/// </param>
/// <param name="keepalive">
/// Keepalive parameters
/// </param>
/// <param name="proxy">
/// HTTP Proxy configuration
/// </param>
/// <param name="connect_timeout">
/// Connection timeout
/// </param>
/// <param name="request_timeout">
/// Request timeout
/// </param>
/// <param name="buffer_size">
/// Read buffer size in bytes
/// </param>
/// <param name="headers">
/// Headers associated with gRPC requests
/// </param>
/// <param name="auth">
/// Authentication configuration for outgoing RPCs
/// </param>
/// <param name="backoff">
/// Backoff retry configuration
/// </param>
/// <param name="metadata">
/// Arbitrary user-provided metadata as JSON string
/// </param>
internal record ClientConfig (
    /// <summary>
    /// The target endpoint the client will connect to
    /// </summary>
    String @endpoint, 
    /// <summary>
    /// Origin (HTTP Host authority override) for the client
    /// </summary>
    String? @origin, 
    /// <summary>
    /// Optional TLS SNI server name override
    /// </summary>
    String? @serverName, 
    /// <summary>
    /// Compression type
    /// </summary>
    CompressionType? @compression, 
    /// <summary>
    /// Rate limit string (e.g., "100/s" for 100 requests per second)
    /// </summary>
    String? @rateLimit, 
    /// <summary>
    /// TLS client configuration
    /// </summary>
    TlsClientConfig @tls, 
    /// <summary>
    /// Keepalive parameters
    /// </summary>
    KeepaliveConfig? @keepalive, 
    /// <summary>
    /// HTTP Proxy configuration
    /// </summary>
    ProxyConfig @proxy, 
    /// <summary>
    /// Connection timeout
    /// </summary>
    TimeSpan @connectTimeout, 
    /// <summary>
    /// Request timeout
    /// </summary>
    TimeSpan @requestTimeout, 
    /// <summary>
    /// Read buffer size in bytes
    /// </summary>
    ulong? @bufferSize, 
    /// <summary>
    /// Headers associated with gRPC requests
    /// </summary>
    Dictionary<String, String> @headers, 
    /// <summary>
    /// Authentication configuration for outgoing RPCs
    /// </summary>
    ClientAuthenticationConfig @auth, 
    /// <summary>
    /// Backoff retry configuration
    /// </summary>
    BackoffConfig @backoff, 
    /// <summary>
    /// Arbitrary user-provided metadata as JSON string
    /// </summary>
    String? @metadata
) {
}

class FfiConverterTypeClientConfig: FfiConverterRustBuffer<ClientConfig> {
    public static FfiConverterTypeClientConfig INSTANCE = new FfiConverterTypeClientConfig();

    public override ClientConfig Read(BigEndianStream stream) {
        return new ClientConfig(
            @endpoint: FfiConverterString.INSTANCE.Read(stream),
            @origin: FfiConverterOptionalString.INSTANCE.Read(stream),
            @serverName: FfiConverterOptionalString.INSTANCE.Read(stream),
            @compression: FfiConverterOptionalTypeCompressionType.INSTANCE.Read(stream),
            @rateLimit: FfiConverterOptionalString.INSTANCE.Read(stream),
            @tls: FfiConverterTypeTlsClientConfig.INSTANCE.Read(stream),
            @keepalive: FfiConverterOptionalTypeKeepaliveConfig.INSTANCE.Read(stream),
            @proxy: FfiConverterTypeProxyConfig.INSTANCE.Read(stream),
            @connectTimeout: FfiConverterDuration.INSTANCE.Read(stream),
            @requestTimeout: FfiConverterDuration.INSTANCE.Read(stream),
            @bufferSize: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @headers: FfiConverterDictionaryStringString.INSTANCE.Read(stream),
            @auth: FfiConverterTypeClientAuthenticationConfig.INSTANCE.Read(stream),
            @backoff: FfiConverterTypeBackoffConfig.INSTANCE.Read(stream),
            @metadata: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ClientConfig value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@endpoint)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@origin)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@serverName)
            + FfiConverterOptionalTypeCompressionType.INSTANCE.AllocationSize(value.@compression)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@rateLimit)
            + FfiConverterTypeTlsClientConfig.INSTANCE.AllocationSize(value.@tls)
            + FfiConverterOptionalTypeKeepaliveConfig.INSTANCE.AllocationSize(value.@keepalive)
            + FfiConverterTypeProxyConfig.INSTANCE.AllocationSize(value.@proxy)
            + FfiConverterDuration.INSTANCE.AllocationSize(value.@connectTimeout)
            + FfiConverterDuration.INSTANCE.AllocationSize(value.@requestTimeout)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@bufferSize)
            + FfiConverterDictionaryStringString.INSTANCE.AllocationSize(value.@headers)
            + FfiConverterTypeClientAuthenticationConfig.INSTANCE.AllocationSize(value.@auth)
            + FfiConverterTypeBackoffConfig.INSTANCE.AllocationSize(value.@backoff)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@metadata);
    }

    public override void Write(ClientConfig value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@endpoint, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@origin, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@serverName, stream);
            FfiConverterOptionalTypeCompressionType.INSTANCE.Write(value.@compression, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@rateLimit, stream);
            FfiConverterTypeTlsClientConfig.INSTANCE.Write(value.@tls, stream);
            FfiConverterOptionalTypeKeepaliveConfig.INSTANCE.Write(value.@keepalive, stream);
            FfiConverterTypeProxyConfig.INSTANCE.Write(value.@proxy, stream);
            FfiConverterDuration.INSTANCE.Write(value.@connectTimeout, stream);
            FfiConverterDuration.INSTANCE.Write(value.@requestTimeout, stream);
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@bufferSize, stream);
            FfiConverterDictionaryStringString.INSTANCE.Write(value.@headers, stream);
            FfiConverterTypeClientAuthenticationConfig.INSTANCE.Write(value.@auth, stream);
            FfiConverterTypeBackoffConfig.INSTANCE.Write(value.@backoff, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@metadata, stream);
    }
}



/// <summary>
/// JWT authentication configuration for client-side signing
/// </summary>
/// <param name="key">
/// JWT key configuration (encoding key for signing)
/// </param>
/// <param name="audience">
/// JWT audience claims to include
/// </param>
/// <param name="issuer">
/// JWT issuer to include
/// </param>
/// <param name="subject">
/// JWT subject to include
/// </param>
/// <param name="duration">
/// Token validity duration (default: 3600 seconds)
/// </param>
internal record ClientJwtAuth (
    /// <summary>
    /// JWT key configuration (encoding key for signing)
    /// </summary>
    JwtKeyType @key, 
    /// <summary>
    /// JWT audience claims to include
    /// </summary>
    List<String>? @audience, 
    /// <summary>
    /// JWT issuer to include
    /// </summary>
    String? @issuer, 
    /// <summary>
    /// JWT subject to include
    /// </summary>
    String? @subject, 
    /// <summary>
    /// Token validity duration (default: 3600 seconds)
    /// </summary>
    TimeSpan @duration
) {
}

class FfiConverterTypeClientJwtAuth: FfiConverterRustBuffer<ClientJwtAuth> {
    public static FfiConverterTypeClientJwtAuth INSTANCE = new FfiConverterTypeClientJwtAuth();

    public override ClientJwtAuth Read(BigEndianStream stream) {
        return new ClientJwtAuth(
            @key: FfiConverterTypeJwtKeyType.INSTANCE.Read(stream),
            @audience: FfiConverterOptionalSequenceString.INSTANCE.Read(stream),
            @issuer: FfiConverterOptionalString.INSTANCE.Read(stream),
            @subject: FfiConverterOptionalString.INSTANCE.Read(stream),
            @duration: FfiConverterDuration.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ClientJwtAuth value) {
        return 0
            + FfiConverterTypeJwtKeyType.INSTANCE.AllocationSize(value.@key)
            + FfiConverterOptionalSequenceString.INSTANCE.AllocationSize(value.@audience)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@issuer)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@subject)
            + FfiConverterDuration.INSTANCE.AllocationSize(value.@duration);
    }

    public override void Write(ClientJwtAuth value, BigEndianStream stream) {
            FfiConverterTypeJwtKeyType.INSTANCE.Write(value.@key, stream);
            FfiConverterOptionalSequenceString.INSTANCE.Write(value.@audience, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@issuer, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@subject, stream);
            FfiConverterDuration.INSTANCE.Write(value.@duration, stream);
    }
}



/// <summary>
/// DataPlane configuration wrapper for uniffi bindings
/// </summary>
/// <param name="servers">
/// DataPlane GRPC server settings
/// </param>
/// <param name="clients">
/// DataPlane client configs
/// </param>
internal record DataplaneConfig (
    /// <summary>
    /// DataPlane GRPC server settings
    /// </summary>
    List<ServerConfig> @servers, 
    /// <summary>
    /// DataPlane client configs
    /// </summary>
    List<ClientConfig> @clients
) {
}

class FfiConverterTypeDataplaneConfig: FfiConverterRustBuffer<DataplaneConfig> {
    public static FfiConverterTypeDataplaneConfig INSTANCE = new FfiConverterTypeDataplaneConfig();

    public override DataplaneConfig Read(BigEndianStream stream) {
        return new DataplaneConfig(
            @servers: FfiConverterSequenceTypeServerConfig.INSTANCE.Read(stream),
            @clients: FfiConverterSequenceTypeClientConfig.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(DataplaneConfig value) {
        return 0
            + FfiConverterSequenceTypeServerConfig.INSTANCE.AllocationSize(value.@servers)
            + FfiConverterSequenceTypeClientConfig.INSTANCE.AllocationSize(value.@clients);
    }

    public override void Write(DataplaneConfig value, BigEndianStream stream) {
            FfiConverterSequenceTypeServerConfig.INSTANCE.Write(value.@servers, stream);
            FfiConverterSequenceTypeClientConfig.INSTANCE.Write(value.@clients, stream);
    }
}



/// <summary>
/// Exponential backoff configuration
/// </summary>
/// <param name="base">
/// Base delay
/// </param>
/// <param name="factor">
/// Multiplication factor for each retry
/// </param>
/// <param name="max_delay">
/// Maximum delay
/// </param>
/// <param name="max_attempts">
/// Maximum number of retry attempts
/// </param>
/// <param name="jitter">
/// Whether to add random jitter to delays
/// </param>
internal record ExponentialBackoff (
    /// <summary>
    /// Base delay
    /// </summary>
    TimeSpan @base, 
    /// <summary>
    /// Multiplication factor for each retry
    /// </summary>
    ulong @factor, 
    /// <summary>
    /// Maximum delay
    /// </summary>
    TimeSpan @maxDelay, 
    /// <summary>
    /// Maximum number of retry attempts
    /// </summary>
    ulong @maxAttempts, 
    /// <summary>
    /// Whether to add random jitter to delays
    /// </summary>
    bool @jitter
) {
}

class FfiConverterTypeExponentialBackoff: FfiConverterRustBuffer<ExponentialBackoff> {
    public static FfiConverterTypeExponentialBackoff INSTANCE = new FfiConverterTypeExponentialBackoff();

    public override ExponentialBackoff Read(BigEndianStream stream) {
        return new ExponentialBackoff(
            @base: FfiConverterDuration.INSTANCE.Read(stream),
            @factor: FfiConverterUInt64.INSTANCE.Read(stream),
            @maxDelay: FfiConverterDuration.INSTANCE.Read(stream),
            @maxAttempts: FfiConverterUInt64.INSTANCE.Read(stream),
            @jitter: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ExponentialBackoff value) {
        return 0
            + FfiConverterDuration.INSTANCE.AllocationSize(value.@base)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@factor)
            + FfiConverterDuration.INSTANCE.AllocationSize(value.@maxDelay)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@maxAttempts)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@jitter);
    }

    public override void Write(ExponentialBackoff value, BigEndianStream stream) {
            FfiConverterDuration.INSTANCE.Write(value.@base, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@factor, stream);
            FfiConverterDuration.INSTANCE.Write(value.@maxDelay, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@maxAttempts, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@jitter, stream);
    }
}



/// <summary>
/// Fixed interval backoff configuration
/// </summary>
/// <param name="interval">
/// Fixed interval between retries
/// </param>
/// <param name="max_attempts">
/// Maximum number of retry attempts
/// </param>
internal record FixedIntervalBackoff (
    /// <summary>
    /// Fixed interval between retries
    /// </summary>
    TimeSpan @interval, 
    /// <summary>
    /// Maximum number of retry attempts
    /// </summary>
    ulong @maxAttempts
) {
}

class FfiConverterTypeFixedIntervalBackoff: FfiConverterRustBuffer<FixedIntervalBackoff> {
    public static FfiConverterTypeFixedIntervalBackoff INSTANCE = new FfiConverterTypeFixedIntervalBackoff();

    public override FixedIntervalBackoff Read(BigEndianStream stream) {
        return new FixedIntervalBackoff(
            @interval: FfiConverterDuration.INSTANCE.Read(stream),
            @maxAttempts: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(FixedIntervalBackoff value) {
        return 0
            + FfiConverterDuration.INSTANCE.AllocationSize(value.@interval)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@maxAttempts);
    }

    public override void Write(FixedIntervalBackoff value, BigEndianStream stream) {
            FfiConverterDuration.INSTANCE.Write(value.@interval, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@maxAttempts, stream);
    }
}



/// <summary>
/// JWT authentication configuration for server-side verification
/// </summary>
/// <param name="key">
/// JWT key configuration (decoding key for verification)
/// </param>
/// <param name="audience">
/// JWT audience claims to verify
/// </param>
/// <param name="issuer">
/// JWT issuer to verify
/// </param>
/// <param name="subject">
/// JWT subject to verify
/// </param>
/// <param name="duration">
/// Token validity duration (default: 3600 seconds)
/// </param>
internal record JwtAuth (
    /// <summary>
    /// JWT key configuration (decoding key for verification)
    /// </summary>
    JwtKeyType @key, 
    /// <summary>
    /// JWT audience claims to verify
    /// </summary>
    List<String>? @audience, 
    /// <summary>
    /// JWT issuer to verify
    /// </summary>
    String? @issuer, 
    /// <summary>
    /// JWT subject to verify
    /// </summary>
    String? @subject, 
    /// <summary>
    /// Token validity duration (default: 3600 seconds)
    /// </summary>
    TimeSpan @duration
) {
}

class FfiConverterTypeJwtAuth: FfiConverterRustBuffer<JwtAuth> {
    public static FfiConverterTypeJwtAuth INSTANCE = new FfiConverterTypeJwtAuth();

    public override JwtAuth Read(BigEndianStream stream) {
        return new JwtAuth(
            @key: FfiConverterTypeJwtKeyType.INSTANCE.Read(stream),
            @audience: FfiConverterOptionalSequenceString.INSTANCE.Read(stream),
            @issuer: FfiConverterOptionalString.INSTANCE.Read(stream),
            @subject: FfiConverterOptionalString.INSTANCE.Read(stream),
            @duration: FfiConverterDuration.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(JwtAuth value) {
        return 0
            + FfiConverterTypeJwtKeyType.INSTANCE.AllocationSize(value.@key)
            + FfiConverterOptionalSequenceString.INSTANCE.AllocationSize(value.@audience)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@issuer)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@subject)
            + FfiConverterDuration.INSTANCE.AllocationSize(value.@duration);
    }

    public override void Write(JwtAuth value, BigEndianStream stream) {
            FfiConverterTypeJwtKeyType.INSTANCE.Write(value.@key, stream);
            FfiConverterOptionalSequenceString.INSTANCE.Write(value.@audience, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@issuer, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@subject, stream);
            FfiConverterDuration.INSTANCE.Write(value.@duration, stream);
    }
}



/// <summary>
/// JWT key configuration
/// </summary>
/// <param name="algorithm">
/// Algorithm used for signing/verifying the JWT
/// </param>
/// <param name="format">
/// Key format - PEM, JWK or JWKS
/// </param>
/// <param name="key">
/// Encoded key or file path
/// </param>
internal record JwtKeyConfig (
    /// <summary>
    /// Algorithm used for signing/verifying the JWT
    /// </summary>
    JwtAlgorithm @algorithm, 
    /// <summary>
    /// Key format - PEM, JWK or JWKS
    /// </summary>
    JwtKeyFormat @format, 
    /// <summary>
    /// Encoded key or file path
    /// </summary>
    JwtKeyData @key
) {
}

class FfiConverterTypeJwtKeyConfig: FfiConverterRustBuffer<JwtKeyConfig> {
    public static FfiConverterTypeJwtKeyConfig INSTANCE = new FfiConverterTypeJwtKeyConfig();

    public override JwtKeyConfig Read(BigEndianStream stream) {
        return new JwtKeyConfig(
            @algorithm: FfiConverterTypeJwtAlgorithm.INSTANCE.Read(stream),
            @format: FfiConverterTypeJwtKeyFormat.INSTANCE.Read(stream),
            @key: FfiConverterTypeJwtKeyData.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(JwtKeyConfig value) {
        return 0
            + FfiConverterTypeJwtAlgorithm.INSTANCE.AllocationSize(value.@algorithm)
            + FfiConverterTypeJwtKeyFormat.INSTANCE.AllocationSize(value.@format)
            + FfiConverterTypeJwtKeyData.INSTANCE.AllocationSize(value.@key);
    }

    public override void Write(JwtKeyConfig value, BigEndianStream stream) {
            FfiConverterTypeJwtAlgorithm.INSTANCE.Write(value.@algorithm, stream);
            FfiConverterTypeJwtKeyFormat.INSTANCE.Write(value.@format, stream);
            FfiConverterTypeJwtKeyData.INSTANCE.Write(value.@key, stream);
    }
}



/// <summary>
/// Keepalive configuration for the client
/// </summary>
/// <param name="tcp_keepalive">
/// TCP keepalive duration
/// </param>
/// <param name="http2_keepalive">
/// HTTP2 keepalive duration
/// </param>
/// <param name="timeout">
/// Keepalive timeout
/// </param>
/// <param name="keep_alive_while_idle">
/// Whether to permit keepalive without an active stream
/// </param>
internal record KeepaliveConfig (
    /// <summary>
    /// TCP keepalive duration
    /// </summary>
    TimeSpan @tcpKeepalive, 
    /// <summary>
    /// HTTP2 keepalive duration
    /// </summary>
    TimeSpan @http2Keepalive, 
    /// <summary>
    /// Keepalive timeout
    /// </summary>
    TimeSpan @timeout, 
    /// <summary>
    /// Whether to permit keepalive without an active stream
    /// </summary>
    bool @keepAliveWhileIdle
) {
}

class FfiConverterTypeKeepaliveConfig: FfiConverterRustBuffer<KeepaliveConfig> {
    public static FfiConverterTypeKeepaliveConfig INSTANCE = new FfiConverterTypeKeepaliveConfig();

    public override KeepaliveConfig Read(BigEndianStream stream) {
        return new KeepaliveConfig(
            @tcpKeepalive: FfiConverterDuration.INSTANCE.Read(stream),
            @http2Keepalive: FfiConverterDuration.INSTANCE.Read(stream),
            @timeout: FfiConverterDuration.INSTANCE.Read(stream),
            @keepAliveWhileIdle: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(KeepaliveConfig value) {
        return 0
            + FfiConverterDuration.INSTANCE.AllocationSize(value.@tcpKeepalive)
            + FfiConverterDuration.INSTANCE.AllocationSize(value.@http2Keepalive)
            + FfiConverterDuration.INSTANCE.AllocationSize(value.@timeout)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@keepAliveWhileIdle);
    }

    public override void Write(KeepaliveConfig value, BigEndianStream stream) {
            FfiConverterDuration.INSTANCE.Write(value.@tcpKeepalive, stream);
            FfiConverterDuration.INSTANCE.Write(value.@http2Keepalive, stream);
            FfiConverterDuration.INSTANCE.Write(value.@timeout, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@keepAliveWhileIdle, stream);
    }
}



/// <summary>
/// Keepalive configuration for the server
/// </summary>
/// <param name="max_connection_idle">
/// Max connection idle time (time after which an idle connection is closed)
/// </param>
/// <param name="max_connection_age">
/// Max connection age (maximum time a connection may exist before being closed)
/// </param>
/// <param name="max_connection_age_grace">
/// Max connection age grace (additional time after max_connection_age before closing)
/// </param>
/// <param name="time">
/// Keepalive ping frequency
/// </param>
/// <param name="timeout">
/// Keepalive ping timeout (time to wait for ack)
/// </param>
internal record KeepaliveServerParameters (
    /// <summary>
    /// Max connection idle time (time after which an idle connection is closed)
    /// </summary>
    TimeSpan @maxConnectionIdle, 
    /// <summary>
    /// Max connection age (maximum time a connection may exist before being closed)
    /// </summary>
    TimeSpan @maxConnectionAge, 
    /// <summary>
    /// Max connection age grace (additional time after max_connection_age before closing)
    /// </summary>
    TimeSpan @maxConnectionAgeGrace, 
    /// <summary>
    /// Keepalive ping frequency
    /// </summary>
    TimeSpan @time, 
    /// <summary>
    /// Keepalive ping timeout (time to wait for ack)
    /// </summary>
    TimeSpan @timeout
) {
}

class FfiConverterTypeKeepaliveServerParameters: FfiConverterRustBuffer<KeepaliveServerParameters> {
    public static FfiConverterTypeKeepaliveServerParameters INSTANCE = new FfiConverterTypeKeepaliveServerParameters();

    public override KeepaliveServerParameters Read(BigEndianStream stream) {
        return new KeepaliveServerParameters(
            @maxConnectionIdle: FfiConverterDuration.INSTANCE.Read(stream),
            @maxConnectionAge: FfiConverterDuration.INSTANCE.Read(stream),
            @maxConnectionAgeGrace: FfiConverterDuration.INSTANCE.Read(stream),
            @time: FfiConverterDuration.INSTANCE.Read(stream),
            @timeout: FfiConverterDuration.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(KeepaliveServerParameters value) {
        return 0
            + FfiConverterDuration.INSTANCE.AllocationSize(value.@maxConnectionIdle)
            + FfiConverterDuration.INSTANCE.AllocationSize(value.@maxConnectionAge)
            + FfiConverterDuration.INSTANCE.AllocationSize(value.@maxConnectionAgeGrace)
            + FfiConverterDuration.INSTANCE.AllocationSize(value.@time)
            + FfiConverterDuration.INSTANCE.AllocationSize(value.@timeout);
    }

    public override void Write(KeepaliveServerParameters value, BigEndianStream stream) {
            FfiConverterDuration.INSTANCE.Write(value.@maxConnectionIdle, stream);
            FfiConverterDuration.INSTANCE.Write(value.@maxConnectionAge, stream);
            FfiConverterDuration.INSTANCE.Write(value.@maxConnectionAgeGrace, stream);
            FfiConverterDuration.INSTANCE.Write(value.@time, stream);
            FfiConverterDuration.INSTANCE.Write(value.@timeout, stream);
    }
}



/// <summary>
/// Generic message context for language bindings (UniFFI-compatible)
///
/// Provides routing and descriptive metadata needed for replying,
/// auditing, and instrumentation across different language bindings.
/// This type is exported to foreign languages via UniFFI.
/// </summary>
/// <param name="source_name">
/// Fully-qualified sender identity
/// </param>
/// <param name="destination_name">
/// Fully-qualified destination identity (may be empty for broadcast/group scenarios)
/// </param>
/// <param name="payload_type">
/// Logical/semantic type (defaults to "msg" if unspecified)
/// </param>
/// <param name="metadata">
/// Arbitrary key/value pairs supplied by the sender (e.g. tracing IDs)
/// </param>
/// <param name="input_connection">
/// Numeric identifier of the inbound connection carrying the message
/// </param>
/// <param name="identity">
/// Identity contained in the message
/// </param>
internal record MessageContext (
    /// <summary>
    /// Fully-qualified sender identity
    /// </summary>
    Name @sourceName, 
    /// <summary>
    /// Fully-qualified destination identity (may be empty for broadcast/group scenarios)
    /// </summary>
    Name? @destinationName, 
    /// <summary>
    /// Logical/semantic type (defaults to "msg" if unspecified)
    /// </summary>
    String @payloadType, 
    /// <summary>
    /// Arbitrary key/value pairs supplied by the sender (e.g. tracing IDs)
    /// </summary>
    Dictionary<String, String> @metadata, 
    /// <summary>
    /// Numeric identifier of the inbound connection carrying the message
    /// </summary>
    ulong @inputConnection, 
    /// <summary>
    /// Identity contained in the message
    /// </summary>
    String @identity
) : IDisposable {
    public void Dispose() {
    FFIObjectUtil.DisposeAll(
            this.@sourceName,
            this.@destinationName,
            this.@payloadType,
            this.@metadata,
            this.@inputConnection,
            this.@identity);
    }
}

class FfiConverterTypeMessageContext: FfiConverterRustBuffer<MessageContext> {
    public static FfiConverterTypeMessageContext INSTANCE = new FfiConverterTypeMessageContext();

    public override MessageContext Read(BigEndianStream stream) {
        return new MessageContext(
            @sourceName: FfiConverterTypeName.INSTANCE.Read(stream),
            @destinationName: FfiConverterOptionalTypeName.INSTANCE.Read(stream),
            @payloadType: FfiConverterString.INSTANCE.Read(stream),
            @metadata: FfiConverterDictionaryStringString.INSTANCE.Read(stream),
            @inputConnection: FfiConverterUInt64.INSTANCE.Read(stream),
            @identity: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(MessageContext value) {
        return 0
            + FfiConverterTypeName.INSTANCE.AllocationSize(value.@sourceName)
            + FfiConverterOptionalTypeName.INSTANCE.AllocationSize(value.@destinationName)
            + FfiConverterString.INSTANCE.AllocationSize(value.@payloadType)
            + FfiConverterDictionaryStringString.INSTANCE.AllocationSize(value.@metadata)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@inputConnection)
            + FfiConverterString.INSTANCE.AllocationSize(value.@identity);
    }

    public override void Write(MessageContext value, BigEndianStream stream) {
            FfiConverterTypeName.INSTANCE.Write(value.@sourceName, stream);
            FfiConverterOptionalTypeName.INSTANCE.Write(value.@destinationName, stream);
            FfiConverterString.INSTANCE.Write(value.@payloadType, stream);
            FfiConverterDictionaryStringString.INSTANCE.Write(value.@metadata, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@inputConnection, stream);
            FfiConverterString.INSTANCE.Write(value.@identity, stream);
    }
}



/// <summary>
/// HTTP Proxy configuration
/// </summary>
/// <param name="url">
/// The HTTP proxy URL (e.g., "http://proxy.example.com:8080")
/// </param>
/// <param name="tls">
/// TLS configuration for proxy connection
/// </param>
/// <param name="username">
/// Optional username for proxy authentication
/// </param>
/// <param name="password">
/// Optional password for proxy authentication
/// </param>
/// <param name="headers">
/// Headers to send with proxy requests
/// </param>
internal record ProxyConfig (
    /// <summary>
    /// The HTTP proxy URL (e.g., "http://proxy.example.com:8080")
    /// </summary>
    String? @url, 
    /// <summary>
    /// TLS configuration for proxy connection
    /// </summary>
    TlsClientConfig @tls, 
    /// <summary>
    /// Optional username for proxy authentication
    /// </summary>
    String? @username, 
    /// <summary>
    /// Optional password for proxy authentication
    /// </summary>
    String? @password, 
    /// <summary>
    /// Headers to send with proxy requests
    /// </summary>
    Dictionary<String, String> @headers
) {
}

class FfiConverterTypeProxyConfig: FfiConverterRustBuffer<ProxyConfig> {
    public static FfiConverterTypeProxyConfig INSTANCE = new FfiConverterTypeProxyConfig();

    public override ProxyConfig Read(BigEndianStream stream) {
        return new ProxyConfig(
            @url: FfiConverterOptionalString.INSTANCE.Read(stream),
            @tls: FfiConverterTypeTlsClientConfig.INSTANCE.Read(stream),
            @username: FfiConverterOptionalString.INSTANCE.Read(stream),
            @password: FfiConverterOptionalString.INSTANCE.Read(stream),
            @headers: FfiConverterDictionaryStringString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ProxyConfig value) {
        return 0
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@url)
            + FfiConverterTypeTlsClientConfig.INSTANCE.AllocationSize(value.@tls)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@username)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@password)
            + FfiConverterDictionaryStringString.INSTANCE.AllocationSize(value.@headers);
    }

    public override void Write(ProxyConfig value, BigEndianStream stream) {
            FfiConverterOptionalString.INSTANCE.Write(value.@url, stream);
            FfiConverterTypeTlsClientConfig.INSTANCE.Write(value.@tls, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@username, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@password, stream);
            FfiConverterDictionaryStringString.INSTANCE.Write(value.@headers, stream);
    }
}



/// <summary>
/// Received message containing context and payload
/// </summary>
internal record ReceivedMessage (
    MessageContext @context, 
    byte[] @payload
) : IDisposable {
    public void Dispose() {
    FFIObjectUtil.DisposeAll(
            this.@context,
            this.@payload);
    }
}

class FfiConverterTypeReceivedMessage: FfiConverterRustBuffer<ReceivedMessage> {
    public static FfiConverterTypeReceivedMessage INSTANCE = new FfiConverterTypeReceivedMessage();

    public override ReceivedMessage Read(BigEndianStream stream) {
        return new ReceivedMessage(
            @context: FfiConverterTypeMessageContext.INSTANCE.Read(stream),
            @payload: FfiConverterByteArray.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ReceivedMessage value) {
        return 0
            + FfiConverterTypeMessageContext.INSTANCE.AllocationSize(value.@context)
            + FfiConverterByteArray.INSTANCE.AllocationSize(value.@payload);
    }

    public override void Write(ReceivedMessage value, BigEndianStream stream) {
            FfiConverterTypeMessageContext.INSTANCE.Write(value.@context, stream);
            FfiConverterByteArray.INSTANCE.Write(value.@payload, stream);
    }
}



/// <summary>
/// Runtime configuration for the SLIM bindings
///
/// Controls the Tokio runtime behavior including thread count, naming, and shutdown timeout.
/// </summary>
/// <param name="n_cores">
/// Number of cores to use for the runtime (0 = use all available cores)
/// </param>
/// <param name="thread_name">
/// Thread name prefix for the runtime
/// </param>
/// <param name="drain_timeout">
/// Timeout duration for draining services during shutdown
/// </param>
internal record RuntimeConfig (
    /// <summary>
    /// Number of cores to use for the runtime (0 = use all available cores)
    /// </summary>
    ulong @nCores, 
    /// <summary>
    /// Thread name prefix for the runtime
    /// </summary>
    String @threadName, 
    /// <summary>
    /// Timeout duration for draining services during shutdown
    /// </summary>
    TimeSpan @drainTimeout
) {
}

class FfiConverterTypeRuntimeConfig: FfiConverterRustBuffer<RuntimeConfig> {
    public static FfiConverterTypeRuntimeConfig INSTANCE = new FfiConverterTypeRuntimeConfig();

    public override RuntimeConfig Read(BigEndianStream stream) {
        return new RuntimeConfig(
            @nCores: FfiConverterUInt64.INSTANCE.Read(stream),
            @threadName: FfiConverterString.INSTANCE.Read(stream),
            @drainTimeout: FfiConverterDuration.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(RuntimeConfig value) {
        return 0
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@nCores)
            + FfiConverterString.INSTANCE.AllocationSize(value.@threadName)
            + FfiConverterDuration.INSTANCE.AllocationSize(value.@drainTimeout);
    }

    public override void Write(RuntimeConfig value, BigEndianStream stream) {
            FfiConverterUInt64.INSTANCE.Write(value.@nCores, stream);
            FfiConverterString.INSTANCE.Write(value.@threadName, stream);
            FfiConverterDuration.INSTANCE.Write(value.@drainTimeout, stream);
    }
}



/// <summary>
/// Server configuration for running a SLIM server
/// </summary>
/// <param name="endpoint">
/// Endpoint address to listen on (e.g., "0.0.0.0:50051" or "[::]:50051")
/// </param>
/// <param name="tls">
/// TLS server configuration
/// </param>
/// <param name="http2_only">
/// Use HTTP/2 only (default: true)
/// </param>
/// <param name="max_frame_size">
/// Maximum size (in MiB) of messages accepted by the server
/// </param>
/// <param name="max_concurrent_streams">
/// Maximum number of concurrent streams per connection
/// </param>
/// <param name="max_header_list_size">
/// Maximum header list size in bytes
/// </param>
/// <param name="read_buffer_size">
/// Read buffer size in bytes
/// </param>
/// <param name="write_buffer_size">
/// Write buffer size in bytes
/// </param>
/// <param name="keepalive">
/// Keepalive parameters
/// </param>
/// <param name="auth">
/// Authentication configuration for incoming requests
/// </param>
/// <param name="metadata">
/// Arbitrary user-provided metadata as JSON string
/// </param>
internal record ServerConfig (
    /// <summary>
    /// Endpoint address to listen on (e.g., "0.0.0.0:50051" or "[::]:50051")
    /// </summary>
    String @endpoint, 
    /// <summary>
    /// TLS server configuration
    /// </summary>
    TlsServerConfig @tls, 
    /// <summary>
    /// Use HTTP/2 only (default: true)
    /// </summary>
    bool @http2Only, 
    /// <summary>
    /// Maximum size (in MiB) of messages accepted by the server
    /// </summary>
    uint? @maxFrameSize, 
    /// <summary>
    /// Maximum number of concurrent streams per connection
    /// </summary>
    uint? @maxConcurrentStreams, 
    /// <summary>
    /// Maximum header list size in bytes
    /// </summary>
    uint? @maxHeaderListSize, 
    /// <summary>
    /// Read buffer size in bytes
    /// </summary>
    ulong? @readBufferSize, 
    /// <summary>
    /// Write buffer size in bytes
    /// </summary>
    ulong? @writeBufferSize, 
    /// <summary>
    /// Keepalive parameters
    /// </summary>
    KeepaliveServerParameters @keepalive, 
    /// <summary>
    /// Authentication configuration for incoming requests
    /// </summary>
    ServerAuthenticationConfig @auth, 
    /// <summary>
    /// Arbitrary user-provided metadata as JSON string
    /// </summary>
    String? @metadata
) {
}

class FfiConverterTypeServerConfig: FfiConverterRustBuffer<ServerConfig> {
    public static FfiConverterTypeServerConfig INSTANCE = new FfiConverterTypeServerConfig();

    public override ServerConfig Read(BigEndianStream stream) {
        return new ServerConfig(
            @endpoint: FfiConverterString.INSTANCE.Read(stream),
            @tls: FfiConverterTypeTlsServerConfig.INSTANCE.Read(stream),
            @http2Only: FfiConverterBoolean.INSTANCE.Read(stream),
            @maxFrameSize: FfiConverterOptionalUInt32.INSTANCE.Read(stream),
            @maxConcurrentStreams: FfiConverterOptionalUInt32.INSTANCE.Read(stream),
            @maxHeaderListSize: FfiConverterOptionalUInt32.INSTANCE.Read(stream),
            @readBufferSize: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @writeBufferSize: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @keepalive: FfiConverterTypeKeepaliveServerParameters.INSTANCE.Read(stream),
            @auth: FfiConverterTypeServerAuthenticationConfig.INSTANCE.Read(stream),
            @metadata: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ServerConfig value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@endpoint)
            + FfiConverterTypeTlsServerConfig.INSTANCE.AllocationSize(value.@tls)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@http2Only)
            + FfiConverterOptionalUInt32.INSTANCE.AllocationSize(value.@maxFrameSize)
            + FfiConverterOptionalUInt32.INSTANCE.AllocationSize(value.@maxConcurrentStreams)
            + FfiConverterOptionalUInt32.INSTANCE.AllocationSize(value.@maxHeaderListSize)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@readBufferSize)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@writeBufferSize)
            + FfiConverterTypeKeepaliveServerParameters.INSTANCE.AllocationSize(value.@keepalive)
            + FfiConverterTypeServerAuthenticationConfig.INSTANCE.AllocationSize(value.@auth)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@metadata);
    }

    public override void Write(ServerConfig value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@endpoint, stream);
            FfiConverterTypeTlsServerConfig.INSTANCE.Write(value.@tls, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@http2Only, stream);
            FfiConverterOptionalUInt32.INSTANCE.Write(value.@maxFrameSize, stream);
            FfiConverterOptionalUInt32.INSTANCE.Write(value.@maxConcurrentStreams, stream);
            FfiConverterOptionalUInt32.INSTANCE.Write(value.@maxHeaderListSize, stream);
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@readBufferSize, stream);
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@writeBufferSize, stream);
            FfiConverterTypeKeepaliveServerParameters.INSTANCE.Write(value.@keepalive, stream);
            FfiConverterTypeServerAuthenticationConfig.INSTANCE.Write(value.@auth, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@metadata, stream);
    }
}



/// <summary>
/// Service configuration wrapper for uniffi bindings
/// </summary>
/// <param name="node_id">
/// Optional node ID for the service
/// </param>
/// <param name="group_name">
/// Optional group name for the service
/// </param>
/// <param name="dataplane">
/// DataPlane configuration (servers and clients)
/// </param>
internal record ServiceConfig (
    /// <summary>
    /// Optional node ID for the service
    /// </summary>
    String? @nodeId, 
    /// <summary>
    /// Optional group name for the service
    /// </summary>
    String? @groupName, 
    /// <summary>
    /// DataPlane configuration (servers and clients)
    /// </summary>
    DataplaneConfig @dataplane
) {
}

class FfiConverterTypeServiceConfig: FfiConverterRustBuffer<ServiceConfig> {
    public static FfiConverterTypeServiceConfig INSTANCE = new FfiConverterTypeServiceConfig();

    public override ServiceConfig Read(BigEndianStream stream) {
        return new ServiceConfig(
            @nodeId: FfiConverterOptionalString.INSTANCE.Read(stream),
            @groupName: FfiConverterOptionalString.INSTANCE.Read(stream),
            @dataplane: FfiConverterTypeDataplaneConfig.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ServiceConfig value) {
        return 0
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@nodeId)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@groupName)
            + FfiConverterTypeDataplaneConfig.INSTANCE.AllocationSize(value.@dataplane);
    }

    public override void Write(ServiceConfig value, BigEndianStream stream) {
            FfiConverterOptionalString.INSTANCE.Write(value.@nodeId, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@groupName, stream);
            FfiConverterTypeDataplaneConfig.INSTANCE.Write(value.@dataplane, stream);
    }
}



/// <summary>
/// Session configuration
/// </summary>
/// <param name="session_type">
/// Session type (PointToPoint or Group)
/// </param>
/// <param name="enable_mls">
/// Enable MLS encryption for this session
/// </param>
/// <param name="max_retries">
/// Maximum number of retries for message transmission (None = use default)
/// </param>
/// <param name="interval">
/// Interval between retries in milliseconds (None = use default)
/// </param>
/// <param name="metadata">
/// Custom metadata key-value pairs for the session
/// </param>
internal record SessionConfig (
    /// <summary>
    /// Session type (PointToPoint or Group)
    /// </summary>
    SessionType @sessionType, 
    /// <summary>
    /// Enable MLS encryption for this session
    /// </summary>
    bool @enableMls, 
    /// <summary>
    /// Maximum number of retries for message transmission (None = use default)
    /// </summary>
    uint? @maxRetries, 
    /// <summary>
    /// Interval between retries in milliseconds (None = use default)
    /// </summary>
    TimeSpan? @interval, 
    /// <summary>
    /// Custom metadata key-value pairs for the session
    /// </summary>
    Dictionary<String, String> @metadata
) {
}

class FfiConverterTypeSessionConfig: FfiConverterRustBuffer<SessionConfig> {
    public static FfiConverterTypeSessionConfig INSTANCE = new FfiConverterTypeSessionConfig();

    public override SessionConfig Read(BigEndianStream stream) {
        return new SessionConfig(
            @sessionType: FfiConverterTypeSessionType.INSTANCE.Read(stream),
            @enableMls: FfiConverterBoolean.INSTANCE.Read(stream),
            @maxRetries: FfiConverterOptionalUInt32.INSTANCE.Read(stream),
            @interval: FfiConverterOptionalDuration.INSTANCE.Read(stream),
            @metadata: FfiConverterDictionaryStringString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SessionConfig value) {
        return 0
            + FfiConverterTypeSessionType.INSTANCE.AllocationSize(value.@sessionType)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@enableMls)
            + FfiConverterOptionalUInt32.INSTANCE.AllocationSize(value.@maxRetries)
            + FfiConverterOptionalDuration.INSTANCE.AllocationSize(value.@interval)
            + FfiConverterDictionaryStringString.INSTANCE.AllocationSize(value.@metadata);
    }

    public override void Write(SessionConfig value, BigEndianStream stream) {
            FfiConverterTypeSessionType.INSTANCE.Write(value.@sessionType, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@enableMls, stream);
            FfiConverterOptionalUInt32.INSTANCE.Write(value.@maxRetries, stream);
            FfiConverterOptionalDuration.INSTANCE.Write(value.@interval, stream);
            FfiConverterDictionaryStringString.INSTANCE.Write(value.@metadata, stream);
    }
}



/// <summary>
/// Result of creating a session, containing the session context and a completion handle
///
/// The completion handle should be awaited to ensure the session is fully established.
/// </summary>
/// <param name="session">
/// The session context for performing operations
/// </param>
/// <param name="completion">
/// Completion handle to wait for session establishment
/// </param>
internal record SessionWithCompletion (
    /// <summary>
    /// The session context for performing operations
    /// </summary>
    Session @session, 
    /// <summary>
    /// Completion handle to wait for session establishment
    /// </summary>
    CompletionHandle @completion
) : IDisposable {
    public void Dispose() {
    FFIObjectUtil.DisposeAll(
            this.@session,
            this.@completion);
    }
}

class FfiConverterTypeSessionWithCompletion: FfiConverterRustBuffer<SessionWithCompletion> {
    public static FfiConverterTypeSessionWithCompletion INSTANCE = new FfiConverterTypeSessionWithCompletion();

    public override SessionWithCompletion Read(BigEndianStream stream) {
        return new SessionWithCompletion(
            @session: FfiConverterTypeSession.INSTANCE.Read(stream),
            @completion: FfiConverterTypeCompletionHandle.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SessionWithCompletion value) {
        return 0
            + FfiConverterTypeSession.INSTANCE.AllocationSize(value.@session)
            + FfiConverterTypeCompletionHandle.INSTANCE.AllocationSize(value.@completion);
    }

    public override void Write(SessionWithCompletion value, BigEndianStream stream) {
            FfiConverterTypeSession.INSTANCE.Write(value.@session, stream);
            FfiConverterTypeCompletionHandle.INSTANCE.Write(value.@completion, stream);
    }
}



/// <summary>
/// SPIRE configuration for SPIFFE Workload API integration
/// </summary>
/// <param name="socket_path">
/// Path to the SPIFFE Workload API socket (None => use SPIFFE_ENDPOINT_SOCKET env var)
/// </param>
/// <param name="target_spiffe_id">
/// Optional target SPIFFE ID when requesting JWT SVIDs
/// </param>
/// <param name="jwt_audiences">
/// Audiences to request/verify for JWT SVIDs
/// </param>
/// <param name="trust_domains">
/// Optional trust domains override for X.509 bundle retrieval
/// </param>
internal record SpireConfig (
    /// <summary>
    /// Path to the SPIFFE Workload API socket (None => use SPIFFE_ENDPOINT_SOCKET env var)
    /// </summary>
    String? @socketPath, 
    /// <summary>
    /// Optional target SPIFFE ID when requesting JWT SVIDs
    /// </summary>
    String? @targetSpiffeId, 
    /// <summary>
    /// Audiences to request/verify for JWT SVIDs
    /// </summary>
    List<String> @jwtAudiences, 
    /// <summary>
    /// Optional trust domains override for X.509 bundle retrieval
    /// </summary>
    List<String> @trustDomains
) {
}

class FfiConverterTypeSpireConfig: FfiConverterRustBuffer<SpireConfig> {
    public static FfiConverterTypeSpireConfig INSTANCE = new FfiConverterTypeSpireConfig();

    public override SpireConfig Read(BigEndianStream stream) {
        return new SpireConfig(
            @socketPath: FfiConverterOptionalString.INSTANCE.Read(stream),
            @targetSpiffeId: FfiConverterOptionalString.INSTANCE.Read(stream),
            @jwtAudiences: FfiConverterSequenceString.INSTANCE.Read(stream),
            @trustDomains: FfiConverterSequenceString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SpireConfig value) {
        return 0
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@socketPath)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@targetSpiffeId)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@jwtAudiences)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@trustDomains);
    }

    public override void Write(SpireConfig value, BigEndianStream stream) {
            FfiConverterOptionalString.INSTANCE.Write(value.@socketPath, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@targetSpiffeId, stream);
            FfiConverterSequenceString.INSTANCE.Write(value.@jwtAudiences, stream);
            FfiConverterSequenceString.INSTANCE.Write(value.@trustDomains, stream);
    }
}



/// <summary>
/// Static JWT (Bearer token) authentication configuration
/// The token is loaded from a file and automatically reloaded when changed
/// </summary>
/// <param name="token_file">
/// Path to file containing the JWT token
/// </param>
/// <param name="duration">
/// Duration for caching the token before re-reading from file (default: 3600 seconds)
/// </param>
internal record StaticJwtAuth (
    /// <summary>
    /// Path to file containing the JWT token
    /// </summary>
    String @tokenFile, 
    /// <summary>
    /// Duration for caching the token before re-reading from file (default: 3600 seconds)
    /// </summary>
    TimeSpan @duration
) {
}

class FfiConverterTypeStaticJwtAuth: FfiConverterRustBuffer<StaticJwtAuth> {
    public static FfiConverterTypeStaticJwtAuth INSTANCE = new FfiConverterTypeStaticJwtAuth();

    public override StaticJwtAuth Read(BigEndianStream stream) {
        return new StaticJwtAuth(
            @tokenFile: FfiConverterString.INSTANCE.Read(stream),
            @duration: FfiConverterDuration.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(StaticJwtAuth value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@tokenFile)
            + FfiConverterDuration.INSTANCE.AllocationSize(value.@duration);
    }

    public override void Write(StaticJwtAuth value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@tokenFile, stream);
            FfiConverterDuration.INSTANCE.Write(value.@duration, stream);
    }
}



/// <summary>
/// TLS configuration for client connections
/// </summary>
/// <param name="insecure">
/// Disable TLS entirely (plain text connection)
/// </param>
/// <param name="insecure_skip_verify">
/// Skip server certificate verification (enables TLS but doesn't verify certs)
/// WARNING: Only use for testing - insecure in production!
/// </param>
/// <param name="source">
/// Certificate and key source for client authentication
/// </param>
/// <param name="ca_source">
/// CA certificate source for verifying server certificates
/// </param>
/// <param name="include_system_ca_certs_pool">
/// Include system CA certificates pool (default: true)
/// </param>
/// <param name="tls_version">
/// TLS version to use: "tls1.2" or "tls1.3" (default: "tls1.3")
/// </param>
internal record TlsClientConfig (
    /// <summary>
    /// Disable TLS entirely (plain text connection)
    /// </summary>
    bool @insecure, 
    /// <summary>
    /// Skip server certificate verification (enables TLS but doesn't verify certs)
    /// WARNING: Only use for testing - insecure in production!
    /// </summary>
    bool @insecureSkipVerify, 
    /// <summary>
    /// Certificate and key source for client authentication
    /// </summary>
    TlsSource @source, 
    /// <summary>
    /// CA certificate source for verifying server certificates
    /// </summary>
    CaSource @caSource, 
    /// <summary>
    /// Include system CA certificates pool (default: true)
    /// </summary>
    bool @includeSystemCaCertsPool, 
    /// <summary>
    /// TLS version to use: "tls1.2" or "tls1.3" (default: "tls1.3")
    /// </summary>
    String @tlsVersion
) {
}

class FfiConverterTypeTlsClientConfig: FfiConverterRustBuffer<TlsClientConfig> {
    public static FfiConverterTypeTlsClientConfig INSTANCE = new FfiConverterTypeTlsClientConfig();

    public override TlsClientConfig Read(BigEndianStream stream) {
        return new TlsClientConfig(
            @insecure: FfiConverterBoolean.INSTANCE.Read(stream),
            @insecureSkipVerify: FfiConverterBoolean.INSTANCE.Read(stream),
            @source: FfiConverterTypeTlsSource.INSTANCE.Read(stream),
            @caSource: FfiConverterTypeCaSource.INSTANCE.Read(stream),
            @includeSystemCaCertsPool: FfiConverterBoolean.INSTANCE.Read(stream),
            @tlsVersion: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TlsClientConfig value) {
        return 0
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@insecure)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@insecureSkipVerify)
            + FfiConverterTypeTlsSource.INSTANCE.AllocationSize(value.@source)
            + FfiConverterTypeCaSource.INSTANCE.AllocationSize(value.@caSource)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@includeSystemCaCertsPool)
            + FfiConverterString.INSTANCE.AllocationSize(value.@tlsVersion);
    }

    public override void Write(TlsClientConfig value, BigEndianStream stream) {
            FfiConverterBoolean.INSTANCE.Write(value.@insecure, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@insecureSkipVerify, stream);
            FfiConverterTypeTlsSource.INSTANCE.Write(value.@source, stream);
            FfiConverterTypeCaSource.INSTANCE.Write(value.@caSource, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@includeSystemCaCertsPool, stream);
            FfiConverterString.INSTANCE.Write(value.@tlsVersion, stream);
    }
}



/// <summary>
/// TLS configuration for server connections
/// </summary>
/// <param name="insecure">
/// Disable TLS entirely (plain text connection)
/// </param>
/// <param name="source">
/// Certificate and key source for server authentication
/// </param>
/// <param name="client_ca">
/// CA certificate source for verifying client certificates
/// </param>
/// <param name="include_system_ca_certs_pool">
/// Include system CA certificates pool (default: true)
/// </param>
/// <param name="tls_version">
/// TLS version to use: "tls1.2" or "tls1.3" (default: "tls1.3")
/// </param>
/// <param name="reload_client_ca_file">
/// Reload client CA file when modified
/// </param>
internal record TlsServerConfig (
    /// <summary>
    /// Disable TLS entirely (plain text connection)
    /// </summary>
    bool @insecure, 
    /// <summary>
    /// Certificate and key source for server authentication
    /// </summary>
    TlsSource @source, 
    /// <summary>
    /// CA certificate source for verifying client certificates
    /// </summary>
    CaSource @clientCa, 
    /// <summary>
    /// Include system CA certificates pool (default: true)
    /// </summary>
    bool @includeSystemCaCertsPool, 
    /// <summary>
    /// TLS version to use: "tls1.2" or "tls1.3" (default: "tls1.3")
    /// </summary>
    String @tlsVersion, 
    /// <summary>
    /// Reload client CA file when modified
    /// </summary>
    bool @reloadClientCaFile
) {
}

class FfiConverterTypeTlsServerConfig: FfiConverterRustBuffer<TlsServerConfig> {
    public static FfiConverterTypeTlsServerConfig INSTANCE = new FfiConverterTypeTlsServerConfig();

    public override TlsServerConfig Read(BigEndianStream stream) {
        return new TlsServerConfig(
            @insecure: FfiConverterBoolean.INSTANCE.Read(stream),
            @source: FfiConverterTypeTlsSource.INSTANCE.Read(stream),
            @clientCa: FfiConverterTypeCaSource.INSTANCE.Read(stream),
            @includeSystemCaCertsPool: FfiConverterBoolean.INSTANCE.Read(stream),
            @tlsVersion: FfiConverterString.INSTANCE.Read(stream),
            @reloadClientCaFile: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TlsServerConfig value) {
        return 0
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@insecure)
            + FfiConverterTypeTlsSource.INSTANCE.AllocationSize(value.@source)
            + FfiConverterTypeCaSource.INSTANCE.AllocationSize(value.@clientCa)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@includeSystemCaCertsPool)
            + FfiConverterString.INSTANCE.AllocationSize(value.@tlsVersion)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@reloadClientCaFile);
    }

    public override void Write(TlsServerConfig value, BigEndianStream stream) {
            FfiConverterBoolean.INSTANCE.Write(value.@insecure, stream);
            FfiConverterTypeTlsSource.INSTANCE.Write(value.@source, stream);
            FfiConverterTypeCaSource.INSTANCE.Write(value.@clientCa, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@includeSystemCaCertsPool, stream);
            FfiConverterString.INSTANCE.Write(value.@tlsVersion, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@reloadClientCaFile, stream);
    }
}



/// <summary>
/// Tracing/logging configuration for the SLIM bindings
///
/// Controls logging behavior including log level, thread name/ID display, and filters.
/// </summary>
/// <param name="log_level">
/// Log level (e.g., "debug", "info", "warn", "error")
/// </param>
/// <param name="display_thread_names">
/// Whether to display thread names in logs
/// </param>
/// <param name="display_thread_ids">
/// Whether to display thread IDs in logs
/// </param>
/// <param name="filters">
/// List of tracing filter directives (e.g., ["slim=debug", "tokio=info"])
/// </param>
internal record TracingConfig (
    /// <summary>
    /// Log level (e.g., "debug", "info", "warn", "error")
    /// </summary>
    String @logLevel, 
    /// <summary>
    /// Whether to display thread names in logs
    /// </summary>
    bool @displayThreadNames, 
    /// <summary>
    /// Whether to display thread IDs in logs
    /// </summary>
    bool @displayThreadIds, 
    /// <summary>
    /// List of tracing filter directives (e.g., ["slim=debug", "tokio=info"])
    /// </summary>
    List<String> @filters
) {
}

class FfiConverterTypeTracingConfig: FfiConverterRustBuffer<TracingConfig> {
    public static FfiConverterTypeTracingConfig INSTANCE = new FfiConverterTypeTracingConfig();

    public override TracingConfig Read(BigEndianStream stream) {
        return new TracingConfig(
            @logLevel: FfiConverterString.INSTANCE.Read(stream),
            @displayThreadNames: FfiConverterBoolean.INSTANCE.Read(stream),
            @displayThreadIds: FfiConverterBoolean.INSTANCE.Read(stream),
            @filters: FfiConverterSequenceString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TracingConfig value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@logLevel)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@displayThreadNames)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@displayThreadIds)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@filters);
    }

    public override void Write(TracingConfig value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@logLevel, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@displayThreadNames, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@displayThreadIds, stream);
            FfiConverterSequenceString.INSTANCE.Write(value.@filters, stream);
    }
}





/// <summary>
/// Backoff retry configuration
/// </summary>
internal record BackoffConfig {
    
    public record Exponential (
        ExponentialBackoff @config
    ) : BackoffConfig {}
    
    public record FixedInterval (
        FixedIntervalBackoff @config
    ) : BackoffConfig {}
    

    
}

class FfiConverterTypeBackoffConfig : FfiConverterRustBuffer<BackoffConfig>{
    public static FfiConverterRustBuffer<BackoffConfig> INSTANCE = new FfiConverterTypeBackoffConfig();

    public override BackoffConfig Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new BackoffConfig.Exponential(
                    FfiConverterTypeExponentialBackoff.INSTANCE.Read(stream)
                );
            case 2:
                return new BackoffConfig.FixedInterval(
                    FfiConverterTypeFixedIntervalBackoff.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeBackoffConfig.Read()", value));
        }
    }

    public override int AllocationSize(BackoffConfig value) {
        switch (value) {
            case BackoffConfig.Exponential variant_value:
                return 4
                    + FfiConverterTypeExponentialBackoff.INSTANCE.AllocationSize(variant_value.@config);
            case BackoffConfig.FixedInterval variant_value:
                return 4
                    + FfiConverterTypeFixedIntervalBackoff.INSTANCE.AllocationSize(variant_value.@config);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeBackoffConfig.AllocationSize()", value));
        }
    }

    public override void Write(BackoffConfig value, BigEndianStream stream) {
        switch (value) {
            case BackoffConfig.Exponential variant_value:
                stream.WriteInt(1);
                FfiConverterTypeExponentialBackoff.INSTANCE.Write(variant_value.@config, stream);
                break;
            case BackoffConfig.FixedInterval variant_value:
                stream.WriteInt(2);
                FfiConverterTypeFixedIntervalBackoff.INSTANCE.Write(variant_value.@config, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeBackoffConfig.Write()", value));
        }
    }
}







/// <summary>
/// CA certificate source configuration
/// </summary>
internal record CaSource {
    
    /// <summary>
    /// Load CA from file
    /// </summary>
    public record File (
        String @path
    ) : CaSource {}
    
    /// <summary>
    /// Load CA from PEM string
    /// </summary>
    public record Pem (
        String @data
    ) : CaSource {}
    
    /// <summary>
    /// Load CA from SPIRE Workload API
    /// </summary>
    public record Spire (
        SpireConfig @config
    ) : CaSource {}
    
    /// <summary>
    /// No CA configured
    /// </summary>
    public record None: CaSource {}
    
    

    
}

class FfiConverterTypeCaSource : FfiConverterRustBuffer<CaSource>{
    public static FfiConverterRustBuffer<CaSource> INSTANCE = new FfiConverterTypeCaSource();

    public override CaSource Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new CaSource.File(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 2:
                return new CaSource.Pem(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 3:
                return new CaSource.Spire(
                    FfiConverterTypeSpireConfig.INSTANCE.Read(stream)
                );
            case 4:
                return new CaSource.None(
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeCaSource.Read()", value));
        }
    }

    public override int AllocationSize(CaSource value) {
        switch (value) {
            case CaSource.File variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@path);
            case CaSource.Pem variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@data);
            case CaSource.Spire variant_value:
                return 4
                    + FfiConverterTypeSpireConfig.INSTANCE.AllocationSize(variant_value.@config);
            case CaSource.None variant_value:
                return 4;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeCaSource.AllocationSize()", value));
        }
    }

    public override void Write(CaSource value, BigEndianStream stream) {
        switch (value) {
            case CaSource.File variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@path, stream);
                break;
            case CaSource.Pem variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@data, stream);
                break;
            case CaSource.Spire variant_value:
                stream.WriteInt(3);
                FfiConverterTypeSpireConfig.INSTANCE.Write(variant_value.@config, stream);
                break;
            case CaSource.None variant_value:
                stream.WriteInt(4);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeCaSource.Write()", value));
        }
    }
}







/// <summary>
/// Authentication configuration enum for client
/// </summary>
internal record ClientAuthenticationConfig {
    
    public record Basic (
        BasicAuth @config
    ) : ClientAuthenticationConfig {}
    
    public record StaticJwt (
        StaticJwtAuth @config
    ) : ClientAuthenticationConfig {}
    
    public record Jwt (
        ClientJwtAuth @config
    ) : ClientAuthenticationConfig {}
    
    public record None: ClientAuthenticationConfig {}
    
    

    
}

class FfiConverterTypeClientAuthenticationConfig : FfiConverterRustBuffer<ClientAuthenticationConfig>{
    public static FfiConverterRustBuffer<ClientAuthenticationConfig> INSTANCE = new FfiConverterTypeClientAuthenticationConfig();

    public override ClientAuthenticationConfig Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new ClientAuthenticationConfig.Basic(
                    FfiConverterTypeBasicAuth.INSTANCE.Read(stream)
                );
            case 2:
                return new ClientAuthenticationConfig.StaticJwt(
                    FfiConverterTypeStaticJwtAuth.INSTANCE.Read(stream)
                );
            case 3:
                return new ClientAuthenticationConfig.Jwt(
                    FfiConverterTypeClientJwtAuth.INSTANCE.Read(stream)
                );
            case 4:
                return new ClientAuthenticationConfig.None(
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeClientAuthenticationConfig.Read()", value));
        }
    }

    public override int AllocationSize(ClientAuthenticationConfig value) {
        switch (value) {
            case ClientAuthenticationConfig.Basic variant_value:
                return 4
                    + FfiConverterTypeBasicAuth.INSTANCE.AllocationSize(variant_value.@config);
            case ClientAuthenticationConfig.StaticJwt variant_value:
                return 4
                    + FfiConverterTypeStaticJwtAuth.INSTANCE.AllocationSize(variant_value.@config);
            case ClientAuthenticationConfig.Jwt variant_value:
                return 4
                    + FfiConverterTypeClientJwtAuth.INSTANCE.AllocationSize(variant_value.@config);
            case ClientAuthenticationConfig.None variant_value:
                return 4;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeClientAuthenticationConfig.AllocationSize()", value));
        }
    }

    public override void Write(ClientAuthenticationConfig value, BigEndianStream stream) {
        switch (value) {
            case ClientAuthenticationConfig.Basic variant_value:
                stream.WriteInt(1);
                FfiConverterTypeBasicAuth.INSTANCE.Write(variant_value.@config, stream);
                break;
            case ClientAuthenticationConfig.StaticJwt variant_value:
                stream.WriteInt(2);
                FfiConverterTypeStaticJwtAuth.INSTANCE.Write(variant_value.@config, stream);
                break;
            case ClientAuthenticationConfig.Jwt variant_value:
                stream.WriteInt(3);
                FfiConverterTypeClientJwtAuth.INSTANCE.Write(variant_value.@config, stream);
                break;
            case ClientAuthenticationConfig.None variant_value:
                stream.WriteInt(4);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeClientAuthenticationConfig.Write()", value));
        }
    }
}







/// <summary>
/// Compression type for gRPC messages
/// </summary>
internal enum CompressionType: int {
    
    Gzip,
    Zlib,
    Deflate,
    Snappy,
    Zstd,
    Lz4,
    None,
    Empty
}

class FfiConverterTypeCompressionType: FfiConverterRustBuffer<CompressionType> {
    public static FfiConverterTypeCompressionType INSTANCE = new FfiConverterTypeCompressionType();

    public override CompressionType Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(CompressionType), value)) {
            return (CompressionType)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeCompressionType.Read()", value));
        }
    }

    public override int AllocationSize(CompressionType value) {
        return 4;
    }

    public override void Write(CompressionType value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







/// <summary>
/// Identity provider configuration - used to prove identity to others
/// </summary>
internal record IdentityProviderConfig {
    
    /// <summary>
    /// Shared secret authentication (symmetric key)
    /// </summary>
    public record SharedSecret (
        String @id,
        String @data
    ) : IdentityProviderConfig {}
    
    /// <summary>
    /// Static JWT loaded from file with auto-reload
    /// </summary>
    public record StaticJwt (
        StaticJwtAuth @config
    ) : IdentityProviderConfig {}
    
    /// <summary>
    /// Dynamic JWT generation with signing key
    /// </summary>
    public record Jwt (
        ClientJwtAuth @config
    ) : IdentityProviderConfig {}
    
    /// <summary>
    /// SPIRE-based identity provider (non-Windows only)
    /// </summary>
    public record Spire (
        SpireConfig @config
    ) : IdentityProviderConfig {}
    
    /// <summary>
    /// No identity provider configured
    /// </summary>
    public record None: IdentityProviderConfig {}
    
    

    
}

class FfiConverterTypeIdentityProviderConfig : FfiConverterRustBuffer<IdentityProviderConfig>{
    public static FfiConverterRustBuffer<IdentityProviderConfig> INSTANCE = new FfiConverterTypeIdentityProviderConfig();

    public override IdentityProviderConfig Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new IdentityProviderConfig.SharedSecret(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 2:
                return new IdentityProviderConfig.StaticJwt(
                    FfiConverterTypeStaticJwtAuth.INSTANCE.Read(stream)
                );
            case 3:
                return new IdentityProviderConfig.Jwt(
                    FfiConverterTypeClientJwtAuth.INSTANCE.Read(stream)
                );
            case 4:
                return new IdentityProviderConfig.Spire(
                    FfiConverterTypeSpireConfig.INSTANCE.Read(stream)
                );
            case 5:
                return new IdentityProviderConfig.None(
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeIdentityProviderConfig.Read()", value));
        }
    }

    public override int AllocationSize(IdentityProviderConfig value) {
        switch (value) {
            case IdentityProviderConfig.SharedSecret variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@id)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@data);
            case IdentityProviderConfig.StaticJwt variant_value:
                return 4
                    + FfiConverterTypeStaticJwtAuth.INSTANCE.AllocationSize(variant_value.@config);
            case IdentityProviderConfig.Jwt variant_value:
                return 4
                    + FfiConverterTypeClientJwtAuth.INSTANCE.AllocationSize(variant_value.@config);
            case IdentityProviderConfig.Spire variant_value:
                return 4
                    + FfiConverterTypeSpireConfig.INSTANCE.AllocationSize(variant_value.@config);
            case IdentityProviderConfig.None variant_value:
                return 4;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeIdentityProviderConfig.AllocationSize()", value));
        }
    }

    public override void Write(IdentityProviderConfig value, BigEndianStream stream) {
        switch (value) {
            case IdentityProviderConfig.SharedSecret variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@id, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@data, stream);
                break;
            case IdentityProviderConfig.StaticJwt variant_value:
                stream.WriteInt(2);
                FfiConverterTypeStaticJwtAuth.INSTANCE.Write(variant_value.@config, stream);
                break;
            case IdentityProviderConfig.Jwt variant_value:
                stream.WriteInt(3);
                FfiConverterTypeClientJwtAuth.INSTANCE.Write(variant_value.@config, stream);
                break;
            case IdentityProviderConfig.Spire variant_value:
                stream.WriteInt(4);
                FfiConverterTypeSpireConfig.INSTANCE.Write(variant_value.@config, stream);
                break;
            case IdentityProviderConfig.None variant_value:
                stream.WriteInt(5);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeIdentityProviderConfig.Write()", value));
        }
    }
}







/// <summary>
/// Identity verifier configuration - used to verify identity of others
/// </summary>
internal record IdentityVerifierConfig {
    
    /// <summary>
    /// Shared secret verification (symmetric key)
    /// </summary>
    public record SharedSecret (
        String @id,
        String @data
    ) : IdentityVerifierConfig {}
    
    /// <summary>
    /// JWT verification with decoding key
    /// </summary>
    public record Jwt (
        JwtAuth @config
    ) : IdentityVerifierConfig {}
    
    /// <summary>
    /// SPIRE-based identity verifier (non-Windows only)
    /// </summary>
    public record Spire (
        SpireConfig @config
    ) : IdentityVerifierConfig {}
    
    /// <summary>
    /// No identity verifier configured
    /// </summary>
    public record None: IdentityVerifierConfig {}
    
    

    
}

class FfiConverterTypeIdentityVerifierConfig : FfiConverterRustBuffer<IdentityVerifierConfig>{
    public static FfiConverterRustBuffer<IdentityVerifierConfig> INSTANCE = new FfiConverterTypeIdentityVerifierConfig();

    public override IdentityVerifierConfig Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new IdentityVerifierConfig.SharedSecret(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 2:
                return new IdentityVerifierConfig.Jwt(
                    FfiConverterTypeJwtAuth.INSTANCE.Read(stream)
                );
            case 3:
                return new IdentityVerifierConfig.Spire(
                    FfiConverterTypeSpireConfig.INSTANCE.Read(stream)
                );
            case 4:
                return new IdentityVerifierConfig.None(
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeIdentityVerifierConfig.Read()", value));
        }
    }

    public override int AllocationSize(IdentityVerifierConfig value) {
        switch (value) {
            case IdentityVerifierConfig.SharedSecret variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@id)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@data);
            case IdentityVerifierConfig.Jwt variant_value:
                return 4
                    + FfiConverterTypeJwtAuth.INSTANCE.AllocationSize(variant_value.@config);
            case IdentityVerifierConfig.Spire variant_value:
                return 4
                    + FfiConverterTypeSpireConfig.INSTANCE.AllocationSize(variant_value.@config);
            case IdentityVerifierConfig.None variant_value:
                return 4;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeIdentityVerifierConfig.AllocationSize()", value));
        }
    }

    public override void Write(IdentityVerifierConfig value, BigEndianStream stream) {
        switch (value) {
            case IdentityVerifierConfig.SharedSecret variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@id, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@data, stream);
                break;
            case IdentityVerifierConfig.Jwt variant_value:
                stream.WriteInt(2);
                FfiConverterTypeJwtAuth.INSTANCE.Write(variant_value.@config, stream);
                break;
            case IdentityVerifierConfig.Spire variant_value:
                stream.WriteInt(3);
                FfiConverterTypeSpireConfig.INSTANCE.Write(variant_value.@config, stream);
                break;
            case IdentityVerifierConfig.None variant_value:
                stream.WriteInt(4);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeIdentityVerifierConfig.Write()", value));
        }
    }
}







/// <summary>
/// JWT signing/verification algorithm
/// </summary>
internal enum JwtAlgorithm: int {
    
    Hs256,
    Hs384,
    Hs512,
    Es256,
    Es384,
    Rs256,
    Rs384,
    Rs512,
    Ps256,
    Ps384,
    Ps512,
    EdDsa
}

class FfiConverterTypeJwtAlgorithm: FfiConverterRustBuffer<JwtAlgorithm> {
    public static FfiConverterTypeJwtAlgorithm INSTANCE = new FfiConverterTypeJwtAlgorithm();

    public override JwtAlgorithm Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(JwtAlgorithm), value)) {
            return (JwtAlgorithm)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeJwtAlgorithm.Read()", value));
        }
    }

    public override int AllocationSize(JwtAlgorithm value) {
        return 4;
    }

    public override void Write(JwtAlgorithm value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







/// <summary>
/// JWT key data source
/// </summary>
internal record JwtKeyData {
    
    /// <summary>
    /// String with encoded key(s)
    /// </summary>
    public record Data (
        String @value
    ) : JwtKeyData {}
    
    /// <summary>
    /// File path to the key(s)
    /// </summary>
    public record File (
        String @path
    ) : JwtKeyData {}
    

    
}

class FfiConverterTypeJwtKeyData : FfiConverterRustBuffer<JwtKeyData>{
    public static FfiConverterRustBuffer<JwtKeyData> INSTANCE = new FfiConverterTypeJwtKeyData();

    public override JwtKeyData Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new JwtKeyData.Data(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 2:
                return new JwtKeyData.File(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeJwtKeyData.Read()", value));
        }
    }

    public override int AllocationSize(JwtKeyData value) {
        switch (value) {
            case JwtKeyData.Data variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@value);
            case JwtKeyData.File variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@path);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeJwtKeyData.AllocationSize()", value));
        }
    }

    public override void Write(JwtKeyData value, BigEndianStream stream) {
        switch (value) {
            case JwtKeyData.Data variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@value, stream);
                break;
            case JwtKeyData.File variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@path, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeJwtKeyData.Write()", value));
        }
    }
}







/// <summary>
/// JWT key format
/// </summary>
internal enum JwtKeyFormat: int {
    
    Pem,
    Jwk,
    Jwks
}

class FfiConverterTypeJwtKeyFormat: FfiConverterRustBuffer<JwtKeyFormat> {
    public static FfiConverterTypeJwtKeyFormat INSTANCE = new FfiConverterTypeJwtKeyFormat();

    public override JwtKeyFormat Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(JwtKeyFormat), value)) {
            return (JwtKeyFormat)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeJwtKeyFormat.Read()", value));
        }
    }

    public override int AllocationSize(JwtKeyFormat value) {
        return 4;
    }

    public override void Write(JwtKeyFormat value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







/// <summary>
/// JWT key type (encoding, decoding, or autoresolve)
/// </summary>
internal record JwtKeyType {
    
    /// <summary>
    /// Encoding key for signing JWTs (client-side)
    /// </summary>
    public record Encoding (
        JwtKeyConfig @key
    ) : JwtKeyType {}
    
    /// <summary>
    /// Decoding key for verifying JWTs (server-side)
    /// </summary>
    public record Decoding (
        JwtKeyConfig @key
    ) : JwtKeyType {}
    
    /// <summary>
    /// Automatically resolve keys based on claims
    /// </summary>
    public record Autoresolve: JwtKeyType {}
    
    

    
}

class FfiConverterTypeJwtKeyType : FfiConverterRustBuffer<JwtKeyType>{
    public static FfiConverterRustBuffer<JwtKeyType> INSTANCE = new FfiConverterTypeJwtKeyType();

    public override JwtKeyType Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new JwtKeyType.Encoding(
                    FfiConverterTypeJwtKeyConfig.INSTANCE.Read(stream)
                );
            case 2:
                return new JwtKeyType.Decoding(
                    FfiConverterTypeJwtKeyConfig.INSTANCE.Read(stream)
                );
            case 3:
                return new JwtKeyType.Autoresolve(
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeJwtKeyType.Read()", value));
        }
    }

    public override int AllocationSize(JwtKeyType value) {
        switch (value) {
            case JwtKeyType.Encoding variant_value:
                return 4
                    + FfiConverterTypeJwtKeyConfig.INSTANCE.AllocationSize(variant_value.@key);
            case JwtKeyType.Decoding variant_value:
                return 4
                    + FfiConverterTypeJwtKeyConfig.INSTANCE.AllocationSize(variant_value.@key);
            case JwtKeyType.Autoresolve variant_value:
                return 4;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeJwtKeyType.AllocationSize()", value));
        }
    }

    public override void Write(JwtKeyType value, BigEndianStream stream) {
        switch (value) {
            case JwtKeyType.Encoding variant_value:
                stream.WriteInt(1);
                FfiConverterTypeJwtKeyConfig.INSTANCE.Write(variant_value.@key, stream);
                break;
            case JwtKeyType.Decoding variant_value:
                stream.WriteInt(2);
                FfiConverterTypeJwtKeyConfig.INSTANCE.Write(variant_value.@key, stream);
                break;
            case JwtKeyType.Autoresolve variant_value:
                stream.WriteInt(3);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeJwtKeyType.Write()", value));
        }
    }
}







/// <summary>
/// Authentication configuration enum for server
/// </summary>
internal record ServerAuthenticationConfig {
    
    public record Basic (
        BasicAuth @config
    ) : ServerAuthenticationConfig {}
    
    public record Jwt (
        JwtAuth @config
    ) : ServerAuthenticationConfig {}
    
    public record None: ServerAuthenticationConfig {}
    
    

    
}

class FfiConverterTypeServerAuthenticationConfig : FfiConverterRustBuffer<ServerAuthenticationConfig>{
    public static FfiConverterRustBuffer<ServerAuthenticationConfig> INSTANCE = new FfiConverterTypeServerAuthenticationConfig();

    public override ServerAuthenticationConfig Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new ServerAuthenticationConfig.Basic(
                    FfiConverterTypeBasicAuth.INSTANCE.Read(stream)
                );
            case 2:
                return new ServerAuthenticationConfig.Jwt(
                    FfiConverterTypeJwtAuth.INSTANCE.Read(stream)
                );
            case 3:
                return new ServerAuthenticationConfig.None(
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeServerAuthenticationConfig.Read()", value));
        }
    }

    public override int AllocationSize(ServerAuthenticationConfig value) {
        switch (value) {
            case ServerAuthenticationConfig.Basic variant_value:
                return 4
                    + FfiConverterTypeBasicAuth.INSTANCE.AllocationSize(variant_value.@config);
            case ServerAuthenticationConfig.Jwt variant_value:
                return 4
                    + FfiConverterTypeJwtAuth.INSTANCE.AllocationSize(variant_value.@config);
            case ServerAuthenticationConfig.None variant_value:
                return 4;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeServerAuthenticationConfig.AllocationSize()", value));
        }
    }

    public override void Write(ServerAuthenticationConfig value, BigEndianStream stream) {
        switch (value) {
            case ServerAuthenticationConfig.Basic variant_value:
                stream.WriteInt(1);
                FfiConverterTypeBasicAuth.INSTANCE.Write(variant_value.@config, stream);
                break;
            case ServerAuthenticationConfig.Jwt variant_value:
                stream.WriteInt(2);
                FfiConverterTypeJwtAuth.INSTANCE.Write(variant_value.@config, stream);
                break;
            case ServerAuthenticationConfig.None variant_value:
                stream.WriteInt(3);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeServerAuthenticationConfig.Write()", value));
        }
    }
}







/// <summary>
/// Session type enum
/// </summary>
internal enum SessionType: int {
    
    PointToPoint,
    Group
}

class FfiConverterTypeSessionType: FfiConverterRustBuffer<SessionType> {
    public static FfiConverterTypeSessionType INSTANCE = new FfiConverterTypeSessionType();

    public override SessionType Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(SessionType), value)) {
            return (SessionType)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSessionType.Read()", value));
        }
    }

    public override int AllocationSize(SessionType value) {
        return 4;
    }

    public override void Write(SessionType value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







/// <summary>
/// Error types for SLIM operations
/// </summary>
internal class SlimException: UniffiException {
    SlimException() : base() {}
    SlimException(String @Message) : base(@Message) {}

    // Each variant is a nested class
    
    
    public class ServiceException : SlimException {
        // Members
        public String @message;

        // Constructor
        public ServiceException(
                String @message) : base(
                "@message" + "=" + @message) {

            this.@message = @message;
        }
    }
    
    
    public class SessionException : SlimException {
        // Members
        public String @message;

        // Constructor
        public SessionException(
                String @message) : base(
                "@message" + "=" + @message) {

            this.@message = @message;
        }
    }
    
    
    public class ReceiveException : SlimException {
        // Members
        public String @message;

        // Constructor
        public ReceiveException(
                String @message) : base(
                "@message" + "=" + @message) {

            this.@message = @message;
        }
    }
    
    
    public class SendException : SlimException {
        // Members
        public String @message;

        // Constructor
        public SendException(
                String @message) : base(
                "@message" + "=" + @message) {

            this.@message = @message;
        }
    }
    
    
    public class AuthException : SlimException {
        // Members
        public String @message;

        // Constructor
        public AuthException(
                String @message) : base(
                "@message" + "=" + @message) {

            this.@message = @message;
        }
    }
    
    
    public class ConfigException : SlimException {
        // Members
        public String @message;

        // Constructor
        public ConfigException(
                String @message) : base(
                "@message" + "=" + @message) {

            this.@message = @message;
        }
    }
    
    public class Timeout : SlimException {
        public Timeout() : base() {}
    }
    
    
    
    public class InvalidArgument : SlimException {
        // Members
        public String @message;

        // Constructor
        public InvalidArgument(
                String @message) : base(
                "@message" + "=" + @message) {

            this.@message = @message;
        }
    }
    
    
    public class InternalException : SlimException {
        // Members
        public String @message;

        // Constructor
        public InternalException(
                String @message) : base(
                "@message" + "=" + @message) {

            this.@message = @message;
        }
    }
    

    
}

class FfiConverterTypeSlimError : FfiConverterRustBuffer<SlimException>, CallStatusErrorHandler<SlimException> {
    public static FfiConverterTypeSlimError INSTANCE = new FfiConverterTypeSlimError();

    public override SlimException Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new SlimException.ServiceException(
                    FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new SlimException.SessionException(
                    FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new SlimException.ReceiveException(
                    FfiConverterString.INSTANCE.Read(stream));
            case 4:
                return new SlimException.SendException(
                    FfiConverterString.INSTANCE.Read(stream));
            case 5:
                return new SlimException.AuthException(
                    FfiConverterString.INSTANCE.Read(stream));
            case 6:
                return new SlimException.ConfigException(
                    FfiConverterString.INSTANCE.Read(stream));
            case 7:
                return new SlimException.Timeout();
            case 8:
                return new SlimException.InvalidArgument(
                    FfiConverterString.INSTANCE.Read(stream));
            case 9:
                return new SlimException.InternalException(
                    FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeSlimError.Read()", value));
        }
    }

    public override int AllocationSize(SlimException value) {
        switch (value) {

            case SlimException.ServiceException variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@message);

            case SlimException.SessionException variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@message);

            case SlimException.ReceiveException variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@message);

            case SlimException.SendException variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@message);

            case SlimException.AuthException variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@message);

            case SlimException.ConfigException variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@message);

            case SlimException.Timeout variant_value:
                return 4;

            case SlimException.InvalidArgument variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@message);

            case SlimException.InternalException variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@message);
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeSlimError.AllocationSize()", value));
        }
    }

    public override void Write(SlimException value, BigEndianStream stream) {
        switch (value) {
            case SlimException.ServiceException variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@message, stream);
                break;
            case SlimException.SessionException variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@message, stream);
                break;
            case SlimException.ReceiveException variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@message, stream);
                break;
            case SlimException.SendException variant_value:
                stream.WriteInt(4);
                FfiConverterString.INSTANCE.Write(variant_value.@message, stream);
                break;
            case SlimException.AuthException variant_value:
                stream.WriteInt(5);
                FfiConverterString.INSTANCE.Write(variant_value.@message, stream);
                break;
            case SlimException.ConfigException variant_value:
                stream.WriteInt(6);
                FfiConverterString.INSTANCE.Write(variant_value.@message, stream);
                break;
            case SlimException.Timeout variant_value:
                stream.WriteInt(7);
                break;
            case SlimException.InvalidArgument variant_value:
                stream.WriteInt(8);
                FfiConverterString.INSTANCE.Write(variant_value.@message, stream);
                break;
            case SlimException.InternalException variant_value:
                stream.WriteInt(9);
                FfiConverterString.INSTANCE.Write(variant_value.@message, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeSlimError.Write()", value));
        }
    }
}





/// <summary>
/// TLS certificate and key source configuration
/// </summary>
internal record TlsSource {
    
    /// <summary>
    /// Load certificate and key from PEM strings
    /// </summary>
    public record Pem (
        String @cert,
        String @key
    ) : TlsSource {}
    
    /// <summary>
    /// Load certificate and key from files (with auto-reload support)
    /// </summary>
    public record File (
        String @cert,
        String @key
    ) : TlsSource {}
    
    /// <summary>
    /// Load certificate and key from SPIRE Workload API
    /// </summary>
    public record Spire (
        SpireConfig @config
    ) : TlsSource {}
    
    /// <summary>
    /// No certificate/key configured
    /// </summary>
    public record None: TlsSource {}
    
    

    
}

class FfiConverterTypeTlsSource : FfiConverterRustBuffer<TlsSource>{
    public static FfiConverterRustBuffer<TlsSource> INSTANCE = new FfiConverterTypeTlsSource();

    public override TlsSource Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new TlsSource.Pem(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 2:
                return new TlsSource.File(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 3:
                return new TlsSource.Spire(
                    FfiConverterTypeSpireConfig.INSTANCE.Read(stream)
                );
            case 4:
                return new TlsSource.None(
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeTlsSource.Read()", value));
        }
    }

    public override int AllocationSize(TlsSource value) {
        switch (value) {
            case TlsSource.Pem variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@cert)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@key);
            case TlsSource.File variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@cert)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@key);
            case TlsSource.Spire variant_value:
                return 4
                    + FfiConverterTypeSpireConfig.INSTANCE.AllocationSize(variant_value.@config);
            case TlsSource.None variant_value:
                return 4;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeTlsSource.AllocationSize()", value));
        }
    }

    public override void Write(TlsSource value, BigEndianStream stream) {
        switch (value) {
            case TlsSource.Pem variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@cert, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@key, stream);
                break;
            case TlsSource.File variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@cert, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@key, stream);
                break;
            case TlsSource.Spire variant_value:
                stream.WriteInt(3);
                FfiConverterTypeSpireConfig.INSTANCE.Write(variant_value.@config, stream);
                break;
            case TlsSource.None variant_value:
                stream.WriteInt(4);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeTlsSource.Write()", value));
        }
    }
}






class FfiConverterOptionalUInt32: FfiConverterRustBuffer<uint?> {
    public static FfiConverterOptionalUInt32 INSTANCE = new FfiConverterOptionalUInt32();

    public override uint? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterUInt32.INSTANCE.Read(stream);
    }

    public override int AllocationSize(uint? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterUInt32.INSTANCE.AllocationSize((uint)value);
        }
    }

    public override void Write(uint? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterUInt32.INSTANCE.Write((uint)value, stream);
        }
    }
}




class FfiConverterOptionalUInt64: FfiConverterRustBuffer<ulong?> {
    public static FfiConverterOptionalUInt64 INSTANCE = new FfiConverterOptionalUInt64();

    public override ulong? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterUInt64.INSTANCE.Read(stream);
    }

    public override int AllocationSize(ulong? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterUInt64.INSTANCE.AllocationSize((ulong)value);
        }
    }

    public override void Write(ulong? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterUInt64.INSTANCE.Write((ulong)value, stream);
        }
    }
}




class FfiConverterOptionalString: FfiConverterRustBuffer<String?> {
    public static FfiConverterOptionalString INSTANCE = new FfiConverterOptionalString();

    public override String? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterString.INSTANCE.Read(stream);
    }

    public override int AllocationSize(String? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterString.INSTANCE.AllocationSize((String)value);
        }
    }

    public override void Write(String? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterString.INSTANCE.Write((String)value, stream);
        }
    }
}




class FfiConverterOptionalDuration: FfiConverterRustBuffer<TimeSpan?> {
    public static FfiConverterOptionalDuration INSTANCE = new FfiConverterOptionalDuration();

    public override TimeSpan? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterDuration.INSTANCE.Read(stream);
    }

    public override int AllocationSize(TimeSpan? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterDuration.INSTANCE.AllocationSize((TimeSpan)value);
        }
    }

    public override void Write(TimeSpan? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterDuration.INSTANCE.Write((TimeSpan)value, stream);
        }
    }
}




class FfiConverterOptionalTypeName: FfiConverterRustBuffer<Name?> {
    public static FfiConverterOptionalTypeName INSTANCE = new FfiConverterOptionalTypeName();

    public override Name? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeName.INSTANCE.Read(stream);
    }

    public override int AllocationSize(Name? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeName.INSTANCE.AllocationSize((Name)value);
        }
    }

    public override void Write(Name? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeName.INSTANCE.Write((Name)value, stream);
        }
    }
}




class FfiConverterOptionalTypeKeepaliveConfig: FfiConverterRustBuffer<KeepaliveConfig?> {
    public static FfiConverterOptionalTypeKeepaliveConfig INSTANCE = new FfiConverterOptionalTypeKeepaliveConfig();

    public override KeepaliveConfig? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeKeepaliveConfig.INSTANCE.Read(stream);
    }

    public override int AllocationSize(KeepaliveConfig? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeKeepaliveConfig.INSTANCE.AllocationSize((KeepaliveConfig)value);
        }
    }

    public override void Write(KeepaliveConfig? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeKeepaliveConfig.INSTANCE.Write((KeepaliveConfig)value, stream);
        }
    }
}




class FfiConverterOptionalTypeCompressionType: FfiConverterRustBuffer<CompressionType?> {
    public static FfiConverterOptionalTypeCompressionType INSTANCE = new FfiConverterOptionalTypeCompressionType();

    public override CompressionType? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeCompressionType.INSTANCE.Read(stream);
    }

    public override int AllocationSize(CompressionType? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeCompressionType.INSTANCE.AllocationSize((CompressionType)value);
        }
    }

    public override void Write(CompressionType? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeCompressionType.INSTANCE.Write((CompressionType)value, stream);
        }
    }
}




class FfiConverterOptionalSequenceString: FfiConverterRustBuffer<List<String>?> {
    public static FfiConverterOptionalSequenceString INSTANCE = new FfiConverterOptionalSequenceString();

    public override List<String>? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterSequenceString.INSTANCE.Read(stream);
    }

    public override int AllocationSize(List<String>? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterSequenceString.INSTANCE.AllocationSize((List<String>)value);
        }
    }

    public override void Write(List<String>? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterSequenceString.INSTANCE.Write((List<String>)value, stream);
        }
    }
}




class FfiConverterOptionalDictionaryStringString: FfiConverterRustBuffer<Dictionary<String, String>?> {
    public static FfiConverterOptionalDictionaryStringString INSTANCE = new FfiConverterOptionalDictionaryStringString();

    public override Dictionary<String, String>? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterDictionaryStringString.INSTANCE.Read(stream);
    }

    public override int AllocationSize(Dictionary<String, String>? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterDictionaryStringString.INSTANCE.AllocationSize((Dictionary<String, String>)value);
        }
    }

    public override void Write(Dictionary<String, String>? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterDictionaryStringString.INSTANCE.Write((Dictionary<String, String>)value, stream);
        }
    }
}




class FfiConverterSequenceString: FfiConverterRustBuffer<List<String>> {
    public static FfiConverterSequenceString INSTANCE = new FfiConverterSequenceString();

    public override List<String> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<String>(length);
        for (int i = 0; i < length; i++) {
            result.Add(FfiConverterString.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<String> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterString.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<String> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterString.INSTANCE.Write(item, stream));
    }
}




class FfiConverterSequenceTypeName: FfiConverterRustBuffer<List<Name>> {
    public static FfiConverterSequenceTypeName INSTANCE = new FfiConverterSequenceTypeName();

    public override List<Name> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<Name>(length);
        for (int i = 0; i < length; i++) {
            result.Add(FfiConverterTypeName.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Name> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeName.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Name> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeName.INSTANCE.Write(item, stream));
    }
}




class FfiConverterSequenceTypeService: FfiConverterRustBuffer<List<Service>> {
    public static FfiConverterSequenceTypeService INSTANCE = new FfiConverterSequenceTypeService();

    public override List<Service> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<Service>(length);
        for (int i = 0; i < length; i++) {
            result.Add(FfiConverterTypeService.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Service> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeService.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Service> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeService.INSTANCE.Write(item, stream));
    }
}




class FfiConverterSequenceTypeClientConfig: FfiConverterRustBuffer<List<ClientConfig>> {
    public static FfiConverterSequenceTypeClientConfig INSTANCE = new FfiConverterSequenceTypeClientConfig();

    public override List<ClientConfig> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<ClientConfig>(length);
        for (int i = 0; i < length; i++) {
            result.Add(FfiConverterTypeClientConfig.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<ClientConfig> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeClientConfig.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<ClientConfig> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeClientConfig.INSTANCE.Write(item, stream));
    }
}




class FfiConverterSequenceTypeServerConfig: FfiConverterRustBuffer<List<ServerConfig>> {
    public static FfiConverterSequenceTypeServerConfig INSTANCE = new FfiConverterSequenceTypeServerConfig();

    public override List<ServerConfig> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<ServerConfig>(length);
        for (int i = 0; i < length; i++) {
            result.Add(FfiConverterTypeServerConfig.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<ServerConfig> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeServerConfig.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<ServerConfig> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeServerConfig.INSTANCE.Write(item, stream));
    }
}




class FfiConverterSequenceTypeServiceConfig: FfiConverterRustBuffer<List<ServiceConfig>> {
    public static FfiConverterSequenceTypeServiceConfig INSTANCE = new FfiConverterSequenceTypeServiceConfig();

    public override List<ServiceConfig> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<ServiceConfig>(length);
        for (int i = 0; i < length; i++) {
            result.Add(FfiConverterTypeServiceConfig.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<ServiceConfig> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeServiceConfig.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<ServiceConfig> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeServiceConfig.INSTANCE.Write(item, stream));
    }
}




class FfiConverterDictionaryStringString: FfiConverterRustBuffer<Dictionary<String, String>> {
    public static FfiConverterDictionaryStringString INSTANCE = new FfiConverterDictionaryStringString();

    public override Dictionary<String, String> Read(BigEndianStream stream) {
        var result = new Dictionary<String, String>();
        var len = stream.ReadInt();
        for (int i = 0; i < len; i++) {
            var key = FfiConverterString.INSTANCE.Read(stream);
            var value = FfiConverterString.INSTANCE.Read(stream);
            result[key] = value;
        }
        return result;
    }

    public override int AllocationSize(Dictionary<String, String> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => {
            return FfiConverterString.INSTANCE.AllocationSize(item.Key) +
                FfiConverterString.INSTANCE.AllocationSize(item.Value);
        }).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(Dictionary<String, String> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        foreach (var item in value) {
            FfiConverterString.INSTANCE.Write(item.Key, stream);
            FfiConverterString.INSTANCE.Write(item.Value, stream);
        }
    }
}



class ConcurrentHandleMap<T> where T: notnull {
    Dictionary<ulong, T> map = new Dictionary<ulong, T>();

    Object lock_ = new Object();
    ulong currentHandle = 0;

    public ulong Insert(T obj) {
        lock (lock_) {
            currentHandle += 1;
            map[currentHandle] = obj;
            return currentHandle;
        }
    }

    public bool TryGet(ulong handle, out T result) {
        lock (lock_) {
            #pragma warning disable 8601 // Possible null reference assignment
            return map.TryGetValue(handle, out result);
            #pragma warning restore 8601
        }
    }

    public T Get(ulong handle) {
        if (TryGet(handle, out var result)) {
            return result;
        } else {
            throw new InternalException("ConcurrentHandleMap: Invalid handle");
        }
    }

    public bool Remove(ulong handle) {
        return Remove(handle, out T result);
    }

    public bool Remove(ulong handle, out T result) {
        lock (lock_) {
            // Possible null reference assignment
            #pragma warning disable 8601
            if (map.TryGetValue(handle, out result)) {
            #pragma warning restore 8601
                map.Remove(handle);
                return true;
            } else {
                return false;
            }
        }
    }
}

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
delegate void UniFfiFutureCallback(IntPtr continuationHandle, byte pollResult);

internal static class _UniFFIAsync {
    internal const byte UNIFFI_RUST_FUTURE_POLL_READY = 0;
    // internal const byte UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1;

    internal static ConcurrentHandleMap<TaskCompletionSource<byte>> _async_handle_map = new ConcurrentHandleMap<TaskCompletionSource<byte>>();
    public static ConcurrentHandleMap<CancellationTokenSource> _foreign_futures_map = new ConcurrentHandleMap<CancellationTokenSource>();

    // FFI type for Rust future continuations
    internal class UniffiRustFutureContinuationCallback
    {
        public static UniFfiFutureCallback callback = Callback;

        public static void Callback(IntPtr continuationHandle, byte pollResult)
        {
            if (_async_handle_map.Remove((ulong)continuationHandle.ToInt64(), out TaskCompletionSource<byte> task))
            {
                task.SetResult(pollResult);
            }
            else 
            {
                throw new InternalException($"Unable to find continuation handle: {continuationHandle}");
            }
        }
    }

    public class UniffiForeignFutureFreeCallback
    {
        public static _UniFFILib.UniffiForeignFutureFree callback = Callback;

        public static void Callback(ulong handle)
        {
            if (_foreign_futures_map.Remove(handle, out CancellationTokenSource task))
            {
                task.Cancel();
            }
            else
            {
                throw new InternalException($"Unable to find cancellation token: {handle}");
            }
        }
    }

    public delegate F CompleteFuncDelegate<F>(IntPtr ptr, ref UniffiRustCallStatus status);

    public delegate void CompleteActionDelegate(IntPtr ptr, ref UniffiRustCallStatus status);

    private static async Task PollFuture(IntPtr rustFuture, Action<IntPtr, IntPtr, IntPtr> pollFunc)
    {
        byte pollResult;
        do 
        {
            var tcs = new TaskCompletionSource<byte>(TaskCreationOptions.RunContinuationsAsynchronously);
            IntPtr callback = Marshal.GetFunctionPointerForDelegate(UniffiRustFutureContinuationCallback.callback);
            ulong mapEntry = _async_handle_map.Insert(tcs);
            pollFunc(rustFuture, callback, (IntPtr)mapEntry);
            pollResult = await tcs.Task;
        }
        while(pollResult != UNIFFI_RUST_FUTURE_POLL_READY);
    }

    public static async Task<T> UniffiRustCallAsync<T, F, E>(
        IntPtr rustFuture,
        Action<IntPtr, IntPtr, IntPtr> pollFunc,
        CompleteFuncDelegate<F> completeFunc,
        Action<IntPtr> freeFunc,
        Func<F, T> liftFunc,
        CallStatusErrorHandler<E> errorHandler
    ) where E : UniffiException
    {
        try {
            await PollFuture(rustFuture, pollFunc);
            var result = _UniffiHelpers.RustCallWithError(errorHandler, (ref UniffiRustCallStatus status) => completeFunc(rustFuture, ref status));
            return liftFunc(result);
        }
        finally
        {
            freeFunc(rustFuture);
        }
    }

    public static async Task UniffiRustCallAsync<E>(
        IntPtr rustFuture,
        Action<IntPtr, IntPtr, IntPtr> pollFunc,
        CompleteActionDelegate completeFunc,
        Action<IntPtr> freeFunc,
        CallStatusErrorHandler<E> errorHandler
    ) where E : UniffiException
    {
         try {
            await PollFuture(rustFuture, pollFunc);
            _UniffiHelpers.RustCallWithError(errorHandler, (ref UniffiRustCallStatus status) => completeFunc(rustFuture, ref status));

        }
        finally
        {
            freeFunc(rustFuture);
        }
    }
}
#pragma warning restore 8625
internal static class SlimBindingsMethods {
    /// <summary>
    /// Create a new Service with builder pattern
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public static Service CreateService(String @name) {
        return FfiConverterTypeService.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_create_service(FfiConverterString.INSTANCE.Lower(@name), ref _status)
));
    }


    /// <summary>
    /// Create a new Service with configuration
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public static Service CreateServiceWithConfig(String @name, ServiceConfig @config) {
        return FfiConverterTypeService.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_create_service_with_config(FfiConverterString.INSTANCE.Lower(@name), FfiConverterTypeServiceConfig.INSTANCE.Lower(@config), ref _status)
));
    }


    /// <summary>
    /// Get detailed build information
    /// </summary>
    public static BuildInfo GetBuildInfo() {
        return FfiConverterTypeBuildInfo.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_get_build_info( ref _status)
));
    }


    /// <summary>
    /// Get the global service instance (creates it if it doesn't exist)
    ///
    /// This returns a reference to the shared global service that can be used
    /// across the application. All calls to this function return the same service instance.
    /// </summary>
    public static Service GetGlobalService() {
        return FfiConverterTypeService.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_get_global_service( ref _status)
));
    }


    /// <summary>
    /// Returns references to all global services.
    /// If not initialized, initializes with defaults first.
    /// </summary>
    public static List<Service> GetServices() {
        return FfiConverterSequenceTypeService.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_get_services( ref _status)
));
    }


    /// <summary>
    /// Get the version of the SLIM bindings (simple string)
    /// </summary>
    public static String GetVersion() {
        return FfiConverterString.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_get_version( ref _status)
));
    }


    /// <summary>
    /// Initialize SLIM bindings from a configuration file
    ///
    /// This function:
    /// 1. Loads the configuration file
    /// 2. Initializes the crypto provider
    /// 3. Sets up tracing/logging exactly as the main SLIM application does
    /// 4. Initializes the global runtime with configuration from the file
    /// 5. Initializes and starts the global service with servers/clients from config
    ///
    /// This must be called before using any SLIM bindings functionality.
    /// It's safe to call multiple times - subsequent calls will be ignored.
    ///
    /// # Arguments
    /// * `config_path` - Path to the YAML configuration file
    ///
    /// # Returns
    /// * `Ok(())` - Successfully initialized
    /// * `Err(SlimError)` - If initialization fails
    ///
    /// # Example
    /// ```ignore
    /// initialize_from_config("/path/to/config.yaml")?;
    /// ```
    /// </summary>
    public static void InitializeFromConfig(String @configPath) {
        
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_initialize_from_config(FfiConverterString.INSTANCE.Lower(@configPath), ref _status)
);
    }


    /// <summary>
    /// Initialize SLIM bindings with custom configuration structs
    ///
    /// This function allows you to programmatically configure SLIM bindings by passing
    /// configuration structs directly, without needing a config file.
    ///
    /// # Arguments
    /// * `runtime_config` - Runtime configuration (thread count, naming, etc.)
    /// * `tracing_config` - Tracing/logging configuration
    /// * `service_config` - Service configuration (node ID, group name, etc.)
    ///
    /// # Returns
    /// * `Ok(())` - Successfully initialized
    /// * `Err(SlimError)` - If initialization fails
    ///
    /// # Example
    /// ```ignore
    /// let runtime_config = new_runtime_config();
    /// let tracing_config = new_tracing_config();
    /// let mut service_config = new_service_config();
    /// service_config.node_id = Some("my-node".to_string());
    ///
    /// initialize_with_configs(runtime_config, tracing_config, service_config)?;
    /// ```
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public static void InitializeWithConfigs(RuntimeConfig @runtimeConfig, TracingConfig @tracingConfig, List<ServiceConfig> @serviceConfig) {
        
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_initialize_with_configs(FfiConverterTypeRuntimeConfig.INSTANCE.Lower(@runtimeConfig), FfiConverterTypeTracingConfig.INSTANCE.Lower(@tracingConfig), FfiConverterSequenceTypeServiceConfig.INSTANCE.Lower(@serviceConfig), ref _status)
);
    }


    /// <summary>
    /// Initialize SLIM bindings with default configuration
    ///
    /// This is a convenience function that initializes the bindings with:
    /// - Default runtime configuration
    /// - Default tracing/logging configuration
    /// - Initialized crypto provider
    /// - Default global service (no servers/clients)
    ///
    /// Use `initialize_from_config` for file-based configuration or
    /// `initialize_with_configs` for programmatic configuration.
    /// </summary>
    public static void InitializeWithDefaults() {
        
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_initialize_with_defaults( ref _status)
);
    }


    /// <summary>
    /// Check if SLIM bindings have been initialized
    /// </summary>
    public static bool IsInitialized() {
        return FfiConverterBoolean.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_is_initialized( ref _status)
));
    }


    /// <summary>
    /// Create a new DataplaneConfig
    /// </summary>
    public static DataplaneConfig NewDataplaneConfig() {
        return FfiConverterTypeDataplaneConfig.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_new_dataplane_config( ref _status)
));
    }


    /// <summary>
    /// Create a new insecure client config (no TLS)
    /// </summary>
    public static ClientConfig NewInsecureClientConfig(String @endpoint) {
        return FfiConverterTypeClientConfig.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_new_insecure_client_config(FfiConverterString.INSTANCE.Lower(@endpoint), ref _status)
));
    }


    /// <summary>
    /// Create a new insecure server config (no TLS)
    /// </summary>
    public static ServerConfig NewInsecureServerConfig(String @endpoint) {
        return FfiConverterTypeServerConfig.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_new_insecure_server_config(FfiConverterString.INSTANCE.Lower(@endpoint), ref _status)
));
    }


    /// <summary>
    /// Create a new BindingsRuntimeConfig with default values
    /// </summary>
    public static RuntimeConfig NewRuntimeConfig() {
        return FfiConverterTypeRuntimeConfig.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_new_runtime_config( ref _status)
));
    }


    /// <summary>
    /// Create a new BindingsRuntimeConfig with custom values
    /// </summary>
    public static RuntimeConfig NewRuntimeConfigWith(ulong @nCores, String @threadName, TimeSpan @drainTimeout) {
        return FfiConverterTypeRuntimeConfig.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_new_runtime_config_with(FfiConverterUInt64.INSTANCE.Lower(@nCores), FfiConverterString.INSTANCE.Lower(@threadName), FfiConverterDuration.INSTANCE.Lower(@drainTimeout), ref _status)
));
    }


    /// <summary>
    /// Create a new server config with the given endpoint and default values
    /// </summary>
    public static ServerConfig NewServerConfig(String @endpoint) {
        return FfiConverterTypeServerConfig.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_new_server_config(FfiConverterString.INSTANCE.Lower(@endpoint), ref _status)
));
    }


    /// <summary>
    /// Create a new BindingsServiceConfig with default values
    /// </summary>
    public static ServiceConfig NewServiceConfig() {
        return FfiConverterTypeServiceConfig.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_new_service_config( ref _status)
));
    }


    /// <summary>
    /// Create a new BindingsServiceConfig with custom values
    /// </summary>
    public static ServiceConfig NewServiceConfigWith(String? @nodeId, String? @groupName, DataplaneConfig @dataplane) {
        return FfiConverterTypeServiceConfig.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_new_service_config_with(FfiConverterOptionalString.INSTANCE.Lower(@nodeId), FfiConverterOptionalString.INSTANCE.Lower(@groupName), FfiConverterTypeDataplaneConfig.INSTANCE.Lower(@dataplane), ref _status)
));
    }


    /// <summary>
    /// Create a new ServiceConfiguration
    /// </summary>
    public static ServiceConfig NewServiceConfiguration() {
        return FfiConverterTypeServiceConfig.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_new_service_configuration( ref _status)
));
    }


    /// <summary>
    /// Create a new BindingsTracingConfig with default values
    /// </summary>
    public static TracingConfig NewTracingConfig() {
        return FfiConverterTypeTracingConfig.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_new_tracing_config( ref _status)
));
    }


    /// <summary>
    /// Create a new BindingsTracingConfig with custom values
    /// </summary>
    public static TracingConfig NewTracingConfigWith(String @logLevel, bool @displayThreadNames, bool @displayThreadIds, List<String> @filters) {
        return FfiConverterTypeTracingConfig.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_new_tracing_config_with(FfiConverterString.INSTANCE.Lower(@logLevel), FfiConverterBoolean.INSTANCE.Lower(@displayThreadNames), FfiConverterBoolean.INSTANCE.Lower(@displayThreadIds), FfiConverterSequenceString.INSTANCE.Lower(@filters), ref _status)
));
    }


    /// <summary>
    /// Perform graceful shutdown operations (blocking version)
    ///
    /// This is a blocking wrapper around the async `shutdown()` function for use from
    /// synchronous contexts or language bindings that don't support async.
    ///
    /// # Returns
    /// * `Ok(())` - Successfully shut down
    /// * `Err(SlimError)` - If shutdown fails
    /// </summary>
    /// <exception cref="SlimException"></exception>
    public static void ShutdownBlocking() {
        
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSlimError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_slim_bindings_fn_func_shutdown_blocking( ref _status)
);
    }


}

